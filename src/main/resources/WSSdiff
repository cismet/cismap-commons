? WSSdiff
Index: de/cismet/cismap/commons/BoundingBox.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/BoundingBox.java,v
retrieving revision 1.15.10.1
retrieving revision 1.15
diff -c -r1.15.10.1 -r1.15
*** de/cismet/cismap/commons/BoundingBox.java	9 Oct 2008 12:08:02 -0000	1.15.10.1
--- de/cismet/cismap/commons/BoundingBox.java	22 Feb 2008 10:07:55 -0000	1.15
***************
*** 1,4 ****
! /*----------------    FILE HEADER  ------------------------------------------ 
   * This file is part of cismap (http://cismap.sourceforge.net)
   *
   * Copyright (C) 2004 by:
--- 1,4 ----
! /*----------------    FILE HEADER  ------------------------------------------
   * This file is part of cismap (http://cismap.sourceforge.net)
   *
   * Copyright (C) 2004 by:
Index: de/cismet/cismap/commons/Version.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/Version.java,v
retrieving revision 1.14
diff -c -r1.14 Version.java
*** de/cismet/cismap/commons/Version.java	7 Mar 2008 11:23:31 -0000	1.14
--- de/cismet/cismap/commons/Version.java	19 Mar 2009 14:56:42 -0000
***************
*** 37,43 ****
   * @author hell
   */
  public class Version  {
!     private  final static String VERSION="cismapCommons.jar Version:2 ($Date: 2009-08-25 13:51:21 $(+2) $Revision: 1.1.1.1 $";
      /** Creates a new instance of Version */
      public Version() {
          
--- 37,43 ----
   * @author hell
   */
  public class Version  {
!     private  final static String VERSION="cismapCommons.jar Version:2 ($Date: 2009-08-25 13:51:21 $(+2) $Revision: 1.1.1.1 $";
      /** Creates a new instance of Version */
      public Version() {
          
Index: de/cismet/cismap/commons/exceptions/BadHttpStatusCodeException.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/exceptions/BadHttpStatusCodeException.java,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -r1.1 -r1.2
*** de/cismet/cismap/commons/exceptions/BadHttpStatusCodeException.java	24 Oct 2006 14:20:55 -0000	1.1
--- de/cismet/cismap/commons/exceptions/BadHttpStatusCodeException.java	14 Nov 2008 12:54:13 -0000	1.2
***************
*** 36,40 ****
      
      public int getHttpStatuscode(){
          return statuscode;
!     }        
  }
--- 36,47 ----
      
      public int getHttpStatuscode(){
          return statuscode;
!     }
! 
!     @Override
!     public String getMessage() {
!         return super.getMessage()+": "+statuscode;
!     }
!     
!     
  }
Index: de/cismet/cismap/commons/features/PureNewFeature.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/features/PureNewFeature.java,v
retrieving revision 1.12
retrieving revision 1.13
diff -c -r1.12 -r1.13
*** de/cismet/cismap/commons/features/PureNewFeature.java	11 Mar 2008 13:45:59 -0000	1.12
--- de/cismet/cismap/commons/features/PureNewFeature.java	6 Oct 2008 08:52:14 -0000	1.13
***************
*** 17,22 ****
--- 17,23 ----
  import de.cismet.cismap.commons.gui.piccolo.FeatureAnnotationSymbol;
  import java.awt.Color;
  import java.awt.Paint;
+ import java.awt.Stroke;
  import java.awt.geom.Point2D;
  import javax.swing.ImageIcon;
  import javax.swing.JComponent;
***************
*** 157,160 ****
--- 158,163 ----
      public float getInfoComponentTransparency() {
          return getTransparency();
      }
+ 
+     
  }
Index: de/cismet/cismap/commons/features/XStyledFeature.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/features/XStyledFeature.java,v
retrieving revision 1.6
retrieving revision 1.7
diff -c -r1.6 -r1.7
*** de/cismet/cismap/commons/features/XStyledFeature.java	3 Mar 2008 14:53:08 -0000	1.6
--- de/cismet/cismap/commons/features/XStyledFeature.java	6 Oct 2008 08:52:14 -0000	1.7
***************
*** 36,41 ****
--- 36,42 ----
  
  import de.cismet.cismap.commons.Refreshable;
  import de.cismet.cismap.commons.gui.piccolo.FeatureAnnotationSymbol;
+ import java.awt.Stroke;
  import javax.swing.ImageIcon;
  import javax.swing.JComponent;
  
***************
*** 48,53 ****
--- 49,55 ----
      public String getName();
      public String getType();
      public JComponent getInfoComponent(Refreshable refresh);
+     public Stroke getLineStyle();
  
      
  }
Index: de/cismet/cismap/commons/featureservice/SimpleUpdateablePostgisFeatureService.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/featureservice/SimpleUpdateablePostgisFeatureService.java,v
retrieving revision 1.4
diff -c -r1.4 SimpleUpdateablePostgisFeatureService.java
*** de/cismet/cismap/commons/featureservice/SimpleUpdateablePostgisFeatureService.java	3 Jun 2008 08:31:50 -0000	1.4
--- de/cismet/cismap/commons/featureservice/SimpleUpdateablePostgisFeatureService.java	19 Mar 2009 14:56:42 -0000
***************
*** 31,51 ****
   * Created on 4. September 2006, 16:55
   *
   */
- 
  package de.cismet.cismap.commons.featureservice;
  
  import de.cismet.cismap.commons.RetrievalServiceLayer;
  import de.cismet.cismap.commons.features.InputEventAwareFeature;
  import de.cismet.cismap.commons.gui.MappingComponent;
- import de.cismet.debugged.JXErrorDialog;
  import edu.umd.cs.piccolo.event.PInputEvent;
  import java.awt.event.ActionEvent;
  import java.awt.event.ActionListener;
  import java.awt.event.InputEvent;
  import javax.swing.ImageIcon;
  import javax.swing.JMenuItem;
  import javax.swing.JPopupMenu;
  
  import org.jdom.CDATA;
  import org.jdom.Element;
  
--- 31,52 ----
   * Created on 4. September 2006, 16:55
   *
   */
  package de.cismet.cismap.commons.featureservice;
  
  import de.cismet.cismap.commons.RetrievalServiceLayer;
  import de.cismet.cismap.commons.features.InputEventAwareFeature;
  import de.cismet.cismap.commons.gui.MappingComponent;
  import edu.umd.cs.piccolo.event.PInputEvent;
  import java.awt.event.ActionEvent;
  import java.awt.event.ActionListener;
  import java.awt.event.InputEvent;
+ import java.util.logging.Level;
  import javax.swing.ImageIcon;
  import javax.swing.JMenuItem;
  import javax.swing.JPopupMenu;
  
+ import org.jdesktop.swingx.JXErrorPane;
+ import org.jdesktop.swingx.error.ErrorInfo;
  import org.jdom.CDATA;
  import org.jdom.Element;
  
***************
*** 53,153 ****
   *
   * @author thorsten.hell@cismet.de
   */
! public class SimpleUpdateablePostgisFeatureService extends SimplePostgisFeatureService implements RetrievalServiceLayer{
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
      String action;
      String actionText;
      ImageIcon icon;
      String iconPath;
!     public final static String ID_TOKEN="<cismap::update::id>";
      /** Creates a new instance of SimpleUpdateablePostgisFeatureService */
      public SimpleUpdateablePostgisFeatureService(Element object) {
          super(object);
!         Element actionElement=null;
          try {
!             actionElement=object.getChild("action");
!             action=actionElement.getText();
          } catch (Exception e) {
!             log.warn("No action in updateable Service",e);
          }
          try {
!             actionText=actionElement.getAttribute("text").getValue();
!             iconPath=actionElement.getAttribute("icon").getValue();
!             icon=new ImageIcon(getClass().getResource(iconPath));
          } catch (Exception e) {
!             log.warn("No actiontext in updateable Service",e);
!             actionText="Aktion ausf\u00FChren";
          }
      }
      public Element getElement() {
!         Element e=super.getElement();
!         e.setAttribute("updateable","true");
!         Element actionElement=new Element("action");
!         actionElement.setAttribute("text",actionText);
!         actionElement.setAttribute("icon",iconPath);
          actionElement.addContent(new CDATA(action));
          e.addContent(actionElement);
          return e;
      }
!     
!     
!     public void doAction(String id) throws Exception{
!         if (action!=null) {
!             java.sql.Statement s=connection.createStatement();
!             String sql=action.replaceAll(ID_TOKEN,id);
!             log.debug("execute: "+sql);
              s.execute(sql);
              s.close();
          }
      }
!     
      public DefaultFeatureServiceFeature getNewFeatureServiceFeature() {
          log.debug("getNewFeatureServiceFeature");
          return new UpdateableFeature();
      }
!     
!     private class UpdateableFeature extends DefaultFeatureServiceFeature implements InputEventAwareFeature{
          public boolean noFurtherEventProcessing(PInputEvent event) {
              return true;
          }
!         
!          
          public void mouseClicked(PInputEvent event) {
          }
!         
!         
          public void mouseEntered(PInputEvent event) {
          }
!         
          public void mouseExited(PInputEvent event) {
          }
!         
!          
          public void mousePressed(PInputEvent event) {
!             final MappingComponent mappingComponent=(MappingComponent)event.getComponent();
!             if (!mappingComponent.isReadOnly()&&event.getModifiers()==InputEvent.BUTTON3_MASK) {
                  log.debug("try to show menu");
!                 JPopupMenu pop=new JPopupMenu();
!                 JMenuItem mni=new JMenuItem(actionText,icon);
                  mni.addActionListener(new ActionListener() {
                      public void actionPerformed(ActionEvent e) {
                          try {
!                             doAction(""+getId());    
                              getFeatureService().retrieve(true);
!                         }
!                         catch (Exception ex) {
!                             log.error("Error during doAction()",ex);
!                             JXErrorDialog.showDialog(mappingComponent,"Fehler","Fehler beim Zugriff auf den FeatureService",ex);
                          }
                      }
                  });
                  pop.add(mni);
!                 pop.show(mappingComponent,(int)event.getCanvasPosition().getX(),(int)event.getCanvasPosition().getY());
!                 
              }
          }
!         
!         
          public void mouseWheelRotated(PInputEvent event) {
          }
  
--- 54,156 ----
   *
   * @author thorsten.hell@cismet.de
   */
! public class SimpleUpdateablePostgisFeatureService extends SimplePostgisFeatureService implements RetrievalServiceLayer {
! 
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
      String action;
      String actionText;
      ImageIcon icon;
      String iconPath;
!     public final static String ID_TOKEN = "<cismap::update::id>";
! 
      /** Creates a new instance of SimpleUpdateablePostgisFeatureService */
      public SimpleUpdateablePostgisFeatureService(Element object) {
          super(object);
!         Element actionElement = null;
          try {
!             actionElement = object.getChild("action");
!             action = actionElement.getText();
          } catch (Exception e) {
!             log.warn("No action in updateable Service", e);
          }
          try {
!             actionText = actionElement.getAttribute("text").getValue();
!             iconPath = actionElement.getAttribute("icon").getValue();
!             icon = new ImageIcon(getClass().getResource(iconPath));
          } catch (Exception e) {
!             log.warn("No actiontext in updateable Service", e);
!             actionText = "Aktion ausf\u00FChren";
          }
      }
+ 
      public Element getElement() {
!         Element e = super.getElement();
!         e.setAttribute("updateable", "true");
!         Element actionElement = new Element("action");
!         actionElement.setAttribute("text", actionText);
!         actionElement.setAttribute("icon", iconPath);
          actionElement.addContent(new CDATA(action));
          e.addContent(actionElement);
          return e;
      }
! 
!     public void doAction(String id) throws Exception {
!         if (action != null) {
!             java.sql.Statement s = connection.createStatement();
!             String sql = action.replaceAll(ID_TOKEN, id);
!             log.debug("execute: " + sql);
              s.execute(sql);
              s.close();
          }
      }
! 
      public DefaultFeatureServiceFeature getNewFeatureServiceFeature() {
          log.debug("getNewFeatureServiceFeature");
          return new UpdateableFeature();
      }
! 
!     private class UpdateableFeature extends DefaultFeatureServiceFeature implements InputEventAwareFeature {
! 
          public boolean noFurtherEventProcessing(PInputEvent event) {
              return true;
          }
! 
          public void mouseClicked(PInputEvent event) {
          }
! 
          public void mouseEntered(PInputEvent event) {
          }
! 
          public void mouseExited(PInputEvent event) {
          }
! 
          public void mousePressed(PInputEvent event) {
!             final MappingComponent mappingComponent = (MappingComponent) event.getComponent();
!             if (!mappingComponent.isReadOnly() && event.getModifiers() == InputEvent.BUTTON3_MASK) {
                  log.debug("try to show menu");
!                 JPopupMenu pop = new JPopupMenu();
!                 JMenuItem mni = new JMenuItem(actionText, icon);
                  mni.addActionListener(new ActionListener() {
+ 
                      public void actionPerformed(ActionEvent e) {
                          try {
!                             doAction("" + getId());
                              getFeatureService().retrieve(true);
!                         } catch (Exception ex) {
!                             log.error("Error during doAction()", ex);
!                             ErrorInfo ei = new ErrorInfo("Fehler", "Fehler beim Zugriff auf den FeatureService", null,null, ex, Level.ALL, null);
!                             JXErrorPane.showDialog(mappingComponent, ei);
! 
! //                            JXErrorDialog.showDialog(mappingComponent,"Fehler","Fehler beim Zugriff auf den FeatureService",ex);
                          }
                      }
                  });
                  pop.add(mni);
!                 pop.show(mappingComponent, (int) event.getCanvasPosition().getX(), (int) event.getCanvasPosition().getY());
! 
              }
          }
! 
          public void mouseWheelRotated(PInputEvent event) {
          }
  
***************
*** 159,165 ****
  
          public void mouseDragged(PInputEvent event) {
          }
-         
      }
-     
  }
--- 162,166 ----
Index: de/cismet/cismap/commons/featureservice/WFSCapabilitiesTreeModel.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/featureservice/WFSCapabilitiesTreeModel.java,v
retrieving revision 1.1.10.1
retrieving revision 1.1
diff -c -r1.1.10.1 -r1.1
*** de/cismet/cismap/commons/featureservice/WFSCapabilitiesTreeModel.java	1 Oct 2008 09:30:57 -0000	1.1.10.1
--- de/cismet/cismap/commons/featureservice/WFSCapabilitiesTreeModel.java	28 Feb 2008 14:05:36 -0000	1.1
***************
*** 33,39 ****
   */
  package de.cismet.cismap.commons.featureservice;
  
- import de.cismet.cismap.commons.capabilities.AbstractCapabilitiesTreeModel;
  import de.cismet.cismap.commons.raster.wms.*;
  import java.util.List;
  import java.util.Vector;
--- 33,38 ----
***************
*** 46,52 ****
   * was dieser anzeigt.
   * @author nh
   */
! public class WFSCapabilitiesTreeModel extends AbstractCapabilitiesTreeModel {
      private WFSCapabilities capabilities = null;
      private Vector listener = new Vector();
      private List<Element> featureTypes = null;
--- 45,51 ----
   * was dieser anzeigt.
   * @author nh
   */
! public class WFSCapabilitiesTreeModel implements TreeModel {
      private WFSCapabilities capabilities = null;
      private Vector listener = new Vector();
      private List<Element> featureTypes = null;
Index: de/cismet/cismap/commons/featureservice/WFSOperator.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/featureservice/WFSOperator.java,v
retrieving revision 1.9.2.2
retrieving revision 1.9
diff -c -r1.9.2.2 -r1.9
*** de/cismet/cismap/commons/featureservice/WFSOperator.java	9 Oct 2008 12:08:02 -0000	1.9.2.2
--- de/cismet/cismap/commons/featureservice/WFSOperator.java	18 Aug 2008 13:46:35 -0000	1.9
***************
*** 4,14 ****
   */
  package de.cismet.cismap.commons.featureservice;
  
- import de.cismet.security.AccessHandler.ACCESS_METHODS;
- import de.cismet.security.WebAccessManager;
  import de.cismet.tools.StaticHtmlTools;
- import java.io.BufferedReader;
- import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.StringReader;
  import java.net.URL;
--- 4,10 ----
***************
*** 17,22 ****
--- 13,22 ----
  import java.util.LinkedList;
  import java.util.List;
  import java.util.Vector;
+ import org.apache.commons.httpclient.HttpClient;
+ import org.apache.commons.httpclient.HttpStatus;
+ import org.apache.commons.httpclient.methods.PostMethod;
+ import org.apache.commons.httpclient.methods.StringRequestEntity;
  import org.deegree2.ogcwebservices.wfs.capabilities.FeatureTypeList;
  import org.deegree2.ogcwebservices.wfs.capabilities.WFSCapabilities;
  import org.deegree2.ogcwebservices.wfs.capabilities.WFSCapabilitiesDocument;
***************
*** 32,38 ****
   * @author nh
   */
  public class WFSOperator {
- 
      /**
       * Log4J Initialisierung
       */
--- 32,37 ----
***************
*** 75,81 ****
      /**
       * XSD-Namespace-Konstante
       */
!     public static final Namespace xsd = Namespace.getNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
  
      /**
       * Standardkonstruktor. Erstellt die XML-Datei mit WFS-Abfragen.
--- 74,80 ----
      /**
       * XSD-Namespace-Konstante
       */
!      public static final Namespace xsd = Namespace.getNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
  
      /**
       * Standardkonstruktor. Erstellt die XML-Datei mit WFS-Abfragen.
***************
*** 120,126 ****
              getQuery().getChild(QUERY, WFS).addContent(tmp);
          }
      }
! 
      /**
       * Durchsucht das übergebene WFSQuery nach vorhandenen Attributen (PropertyNames)
       * und liefert diese als String-Vector zurück.
--- 119,125 ----
              getQuery().getChild(QUERY, WFS).addContent(tmp);
          }
      }
!     
      /**
       * Durchsucht das übergebene WFSQuery nach vorhandenen Attributen (PropertyNames)
       * und liefert diese als String-Vector zurück.
***************
*** 131,139 ****
          Vector<String> result = new Vector<String>();
          try {
              for (Object o : query.getChild(QUERY, WFS).getChildren(PROPERTY_NAME, WFS)) {
!                 if (o instanceof Element) {
!                     result.add(((Element) o).getText());
!                 }
              }
              log.debug(result);
          } catch (Exception ex) {
--- 130,137 ----
          Vector<String> result = new Vector<String>();
          try {
              for (Object o : query.getChild(QUERY, WFS).getChildren(PROPERTY_NAME, WFS)) {
!                 if (o instanceof Element)
!                     result.add(((Element)o).getText());
              }
              log.debug(result);
          } catch (Exception ex) {
***************
*** 142,148 ****
          }
          return result;
      }
! 
      /**
       * Ersetzt die bisher in der Query vorhandenen Properties durch die der
       * übergebenen String-Collection.
--- 140,146 ----
          }
          return result;
      }
!     
      /**
       * Ersetzt die bisher in der Query vorhandenen Properties durch die der
       * übergebenen String-Collection.
***************
*** 166,193 ****
      public void setGeometry(Element e) {
          for (Element tmp : (List<Element>) e.getChildren()) {
              if (tmp.getAttributeValue("type").equals(GEO_PROPERTY_TYPE)) {
!                 getQuery().getChild(QUERY, WFS).getChild(FILTER, OGC).getChild(BBOX, OGC).getChild(PROPERTY_NAME, OGC).setText(tmp.getAttributeValue("name"));
                  break;
              }
          }
      }
! 
      /**
       * Setzt den Geometrie-Namen.
       * @param query WFSQuery als JDOM-Element
       * @param s String mit dem Geometrie-Namen
       */
      public static void setGeometry(Element query, String s) {
!         query.getChild(QUERY, WFS).getChild(FILTER, OGC).getChild(BBOX, OGC).getChild(PROPERTY_NAME, OGC).setText(s);
      }
! 
      /**
       * Liefert den im Query-Element gesetzten Geometrienamen.
       * @param query WFSQuery als JDOM-Element
       * @return String mit dem Geometrie-Namen
       */
      public static String getGeometry(Element query) {
!         return query.getChild(QUERY, WFS).getChild(FILTER, OGC).getChild(BBOX, OGC).getChild(PROPERTY_NAME, OGC).getTextTrim();
      }
  
      /**
--- 164,194 ----
      public void setGeometry(Element e) {
          for (Element tmp : (List<Element>) e.getChildren()) {
              if (tmp.getAttributeValue("type").equals(GEO_PROPERTY_TYPE)) {
!                 getQuery().getChild(QUERY, WFS).getChild(FILTER, OGC).getChild(BBOX, OGC)
!                         .getChild(PROPERTY_NAME, OGC).setText(tmp.getAttributeValue("name"));
                  break;
              }
          }
      }
!     
      /**
       * Setzt den Geometrie-Namen.
       * @param query WFSQuery als JDOM-Element
       * @param s String mit dem Geometrie-Namen
       */
      public static void setGeometry(Element query, String s) {
!         query.getChild(QUERY, WFS).getChild(FILTER, OGC).getChild(BBOX, OGC)
!                 .getChild(PROPERTY_NAME, OGC).setText(s);
      }
!     
      /**
       * Liefert den im Query-Element gesetzten Geometrienamen.
       * @param query WFSQuery als JDOM-Element
       * @return String mit dem Geometrie-Namen
       */
      public static String getGeometry(Element query) {
!         return query.getChild(QUERY, WFS).getChild(FILTER, OGC).getChild(BBOX, OGC)
!                 .getChild(PROPERTY_NAME, OGC).getTextTrim();
      }
  
      /**
***************
*** 247,258 ****
          wfsDoc.load(new StringReader(buf), "http://test0r");
          return (WFSCapabilities) wfsDoc.parseCapabilities();
      }
-     
-     public WFSCapabilities parseWFSCapabilites(BufferedReader reader) throws Exception {        
-         WFSCapabilitiesDocument wfsDoc = new WFSCapabilitiesDocument();
-         wfsDoc.load(reader, "http://test0r");
-         return (WFSCapabilities) wfsDoc.parseCapabilities();
-     }
  
      /**
       * Liefert, falls in den Capabilities vorhanden, einen Namen f\u00FCr den WFS
--- 248,253 ----
***************
*** 363,369 ****
                              log.debug(">> Element mit Name = \"" + name + "\" gefunden");
                              e.setAttribute("name", name);
                              result = e;
!                             prefix = e.getAttributeValue("type").substring(0, e.getAttributeValue("type").indexOf(":") + 1);
                              type = deleteApp(e.getAttributeValue("type"));
                              log.debug(">> gesuchter Typ = \"" + e.getAttributeValue("type") + "\"");
                              break;
--- 358,364 ----
                              log.debug(">> Element mit Name = \"" + name + "\" gefunden");
                              e.setAttribute("name", name);
                              result = e;
!                             prefix = e.getAttributeValue("type").substring(0, e.getAttributeValue("type").indexOf(":")+1);
                              type = deleteApp(e.getAttributeValue("type"));
                              log.debug(">> gesuchter Typ = \"" + e.getAttributeValue("type") + "\"");
                              break;
***************
*** 378,384 ****
                              List l = comp.getChild("complexContent", xsd).getChild("extension", xsd).getChild("sequence", xsd).getChildren("element", xsd);
                              while (l.size() > 0) {
                                  Element neu = ((Element) l.get(0)).detach();
!                                 neu.setAttribute("name", prefix + neu.getAttributeValue("name"));
                                  result.addContent(neu);
                              }
                              log.debug("Alles OK, Ergebnis = " + result);
--- 373,379 ----
                              List l = comp.getChild("complexContent", xsd).getChild("extension", xsd).getChild("sequence", xsd).getChildren("element", xsd);
                              while (l.size() > 0) {
                                  Element neu = ((Element) l.get(0)).detach();
!                                 neu.setAttribute("name", prefix+neu.getAttributeValue("name"));
                                  result.addContent(neu);
                              }
                              log.debug("Alles OK, Ergebnis = " + result);
***************
*** 415,471 ****
       * @return Serverantwort als InputStream
       */
      public static Document doRequest(URL serverURL, String request) throws Exception {
! //        log.info("HTTPCommunicator.doRequest()");
! //        // HTTP-Client erstellen
! //        HttpClient client = new HttpClient();
! //
! //        // Hole den Status, ob momentan ein Proxy gesetzt ist
! //        String proxySet = System.getProperty("proxySet");
! //
! //        // Proxy vorhanden ...
! //        if (proxySet != null && proxySet.equals("true")) {
! //            log.debug("Proxy vorhanden");
! //            log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
! //            log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
! //            try {
! //                // F\u00FCge den vorhandenen Proxy dem HTTP-Client hinzu
! //                client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"),
! //                        Integer.parseInt(System.getProperty("http.proxyPort")));
! //            } catch (Exception ex) {
! //                log.error("Proxy im HTTP-Client setzen fehlgeschlagen", ex);
! //            }
! //
! //        } else { // sonst tue nichts
! //            log.debug("kein Proxy");
! //        }
! //
! //        // Erstelle neue POST-Methode mit der Server-URL
! //        PostMethod httppost = new PostMethod(serverURL.toString());
! //        log.debug("ServerURL = " + httppost.getURI().toString());
! //
! //        // Requeststring speichern, damit das Original nicht ver\u00E4ndert wird.
          String poststring = request;
! //
! //        // Erstelle HTML aus dem Request und \u00E4ndere sein Charset auf ISO
          log.debug("WFS Query = " + StaticHtmlTools.stringToHTMLString(poststring));
!         //String modifiedString = new String(poststring.getBytes("UTF-8"), "ISO-8859-1");
! //        httppost.setRequestEntity(new StringRequestEntity(modifiedString));
  
          try {
              //POST-Methode an den Server schicken
!             //client.executeMethod(httppost);
!             final InputStream result = WebAccessManager.getInstance().doRequest(serverURL, new StringReader(poststring), ACCESS_METHODS.POST_REQUEST);
              // Falls Antwort == OK
!             //if (httppost.getStatusCode() == HttpStatus.SC_OK) {
!             log.debug("Server hat Request bearbeitet und antwortet");
!             log.debug("InputStream parsen");
!             SAXBuilder builder = new SAXBuilder();
!             return builder.build(new InputStreamReader(result, Charset.forName("UTF-8")));
! //            } else {
! //                log.error("Unexpected failure: " + httppost.getStatusLine().toString());
! //            }
!         } catch (Exception ex) {
!             log.error(ex);
          }
          return null;
      }
--- 410,466 ----
       * @return Serverantwort als InputStream
       */
      public static Document doRequest(URL serverURL, String request) throws Exception {
!         log.info("HTTPCommunicator.doRequest()");
!         // HTTP-Client erstellen
!         HttpClient client = new HttpClient();
! 
!         // Hole den Status, ob momentan ein Proxy gesetzt ist
!         String proxySet = System.getProperty("proxySet");
! 
!         // Proxy vorhanden ...
!         if (proxySet != null && proxySet.equals("true")) {
!             log.debug("Proxy vorhanden");
!             log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
!             log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
!             try {
!                 // F\u00FCge den vorhandenen Proxy dem HTTP-Client hinzu
!                 client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"),
!                         Integer.parseInt(System.getProperty("http.proxyPort")));
!             } catch (Exception ex) {
!                 log.error("Proxy im HTTP-Client setzen fehlgeschlagen", ex);
!             }
! 
!         } else { // sonst tue nichts
!             log.debug("kein Proxy");
!         }
! 
!         // Erstelle neue POST-Methode mit der Server-URL
!         PostMethod httppost = new PostMethod(serverURL.toString());
!         log.debug("ServerURL = " + httppost.getURI().toString());
! 
!         // Requeststring speichern, damit das Original nicht ver\u00E4ndert wird.
          String poststring = request;
! 
!         // Erstelle HTML aus dem Request und \u00E4ndere sein Charset auf ISO
          log.debug("WFS Query = " + StaticHtmlTools.stringToHTMLString(poststring));
!         String modifiedString = new String(poststring.getBytes("UTF-8"), "ISO-8859-1");
!         httppost.setRequestEntity(new StringRequestEntity(modifiedString));
  
          try {
              //POST-Methode an den Server schicken
!             client.executeMethod(httppost);
! 
              // Falls Antwort == OK
!             if (httppost.getStatusCode() == HttpStatus.SC_OK) {
!                 log.debug("Server hat Request bearbeitet und antwortet");
!                 log.debug("InputStream parsen");
!                 SAXBuilder builder = new SAXBuilder();
!                 return builder.build(new InputStreamReader(httppost.getResponseBodyAsStream(), Charset.forName("UTF-8")));
!             } else {
!                 log.error("Unexpected failure: " + httppost.getStatusLine().toString());
!             }
!         } finally {
!             httppost.releaseConnection();
          }
          return null;
      }
Index: de/cismet/cismap/commons/gui/MappingComponent.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/MappingComponent.java,v
retrieving revision 1.111
retrieving revision 1.113
diff -c -r1.111 -r1.113
*** de/cismet/cismap/commons/gui/MappingComponent.java	8 Jul 2008 15:12:30 -0000	1.111
--- de/cismet/cismap/commons/gui/MappingComponent.java	11 Feb 2009 13:49:58 -0000	1.113
***************
*** 523,528 ****
--- 523,531 ----
          }
      }
  
+ 
+ 
+ 
      /**
       * Creates an image with given width and height from all features that intersects
       * the printingframe.
***************
*** 1014,1019 ****
--- 1017,1030 ----
          featureCollection.addFeatureCollectionListener(this);
      }
  
+     public void setFeatureCollectionVisibility(boolean visibility) {
+         featureLayer.setVisible(visibility);
+     }
+     
+     public boolean isFeatureCollectionVisible(){
+         return featureLayer.getVisible();
+     }
+     
      /**
       * Adds a new mapservice at a specific place of the layercontrols.
       * @param mapService the new mapservice
Index: de/cismet/cismap/commons/gui/capabilitywidget/CapabilityWidget.form
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/capabilitywidget/CapabilityWidget.form,v
retrieving revision 1.12.10.1
retrieving revision 1.12
diff -c -r1.12.10.1 -r1.12
*** de/cismet/cismap/commons/gui/capabilitywidget/CapabilityWidget.form	1 Oct 2008 09:30:58 -0000	1.12.10.1
--- de/cismet/cismap/commons/gui/capabilitywidget/CapabilityWidget.form	28 Feb 2008 14:07:28 -0000	1.12
***************
*** 12,18 ****
      </Property>
    </Properties>
    <AuxValues>
-     <AuxValue name="FormSettings_autoSetComponentName" type="java.lang.Boolean" value="false"/>
      <AuxValue name="FormSettings_formBundle" type="java.lang.String" value="de/cismet/cismap/commons/GuiBundle"/>
      <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
      <AuxValue name="FormSettings_i18nAutoMode" type="java.lang.Boolean" value="true"/>
--- 12,17 ----
Index: de/cismet/cismap/commons/gui/capabilitywidget/CapabilityWidget.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/capabilitywidget/CapabilityWidget.java,v
retrieving revision 1.38.6.3
retrieving revision 1.38
diff -c -r1.38.6.3 -r1.38
*** de/cismet/cismap/commons/gui/capabilitywidget/CapabilityWidget.java	9 Oct 2008 12:08:02 -0000	1.38.6.3
--- de/cismet/cismap/commons/gui/capabilitywidget/CapabilityWidget.java	9 Jun 2008 15:40:46 -0000	1.38
***************
*** 35,41 ****
  
  import com.jgoodies.looks.Options;
  import com.jgoodies.looks.plastic.PlasticXPLookAndFeel;
- import de.cismet.cismap.commons.capabilities.AbstractCapabilitiesTreeModel;
  import de.cismet.cismap.commons.interaction.CismapBroker;
  import de.cismet.cismap.commons.interaction.MapBoundsListener;
  import de.cismet.cismap.commons.interaction.events.CapabilityEvent;
--- 35,40 ----
***************
*** 48,58 ****
  import de.cismet.cismap.commons.raster.wms.WMSCapabilitiesTreeCellRenderer;
  import de.cismet.cismap.commons.raster.wms.WMSCapabilitiesTreeModel;
  import de.cismet.cismap.commons.rasterservice.HttpAuthentication;
- import de.cismet.security.AccessHandler;
- import de.cismet.security.WSSPasswordDialog;
- import de.cismet.security.WebAccessManager;
- import de.cismet.security.exceptions.RequestFailedException;
- import de.cismet.security.handler.WSSAccessHandler;
  import de.cismet.tools.configuration.Configurable;
  import de.cismet.tools.gui.StaticSwingTools;
  
--- 47,52 ----
***************
*** 82,93 ****
  import java.awt.event.InputEvent;
  import java.awt.event.MouseAdapter;
  import java.awt.event.MouseEvent;
- import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.InputStreamReader;
- import java.io.StringReader;
- import java.net.MalformedURLException;
  import java.net.URL;
  import java.util.HashMap;
  import java.util.Iterator;
--- 76,84 ----
***************
*** 172,178 ****
          // Text im Tab der L\u00E4nge der URL anpassen
          String tabText;
          if (subparent != null && subparent.trim().length() > 0) {
!             tabText = subparent;
          } else {
              if (link.startsWith("http://") && link.length() > 21) {
                  tabText = link.substring(7, 21) + "...";
--- 163,169 ----
          // Text im Tab der L\u00E4nge der URL anpassen
          String tabText;
          if (subparent != null && subparent.trim().length() > 0) {
!             tabText=subparent;
          } else {
              if (link.startsWith("http://") && link.length() > 21) {
                  tabText = link.substring(7, 21) + "...";
***************
*** 187,193 ****
          final Object test = capabilityUrls.get(new LinkWithSubparent(link, subparent));
          final String tabTextCopy = tabText;
          EventQueue.invokeLater(new Runnable() {
- 
              public void run() {
                  if (test != null && test instanceof JComponent) {
                      synchronized (this) {
--- 178,183 ----
***************
*** 201,228 ****
                  }
                  tbpCapabilities.setSelectedComponent(load);
                  // setOGCWMSCapabilitiesTree(link, tbpCapabilities.getComponentCount()-1);
! 
                  //TODO
!                 //should be refactored --> coomon parts like capabilities s
                  if (link.toLowerCase().contains("service=wfs")) {
                      addOGCWFSCapabilitiesTree(link, load, interactive);
!                 } else if (link.toLowerCase().contains("service=wms")) {
                      addOGCWMSCapabilitiesTree(link, load, interactive, subparent);
-                 } else if (link.toLowerCase().contains("service=wss")) {
-                     try {
-                         log.debug("WSS Capabilties Link hinzugefügt");
-                         final URL url = new URL(link.substring(0, link.indexOf('?')));
-                         log.debug("URL des WSS: " + url.toString());
-                         if (!WebAccessManager.getInstance().isHandlerForURLRegistered(url)) {
-                             WebAccessManager.getInstance().registerAccessHandler(url, AccessHandler.ACCESS_HANDLER_TYPES.WSS);
-                         }
-                         addOGCCapabilitiesTree(link, load, interactive);
-                     } catch (MalformedURLException ex) {
-                         log.error("Url is not wellformed no wss authentication possible", ex);
-                     }
                  } else {
!                     //ToDo cleveres Probieren wenn z.B. nur die service URL angebenen wurde --> getCapabiltiesrequest aufbauen und probieren
!                     Object[] alternatives = {"OGC-Web Mapping Service", "OGC-Web Feature Service", "OGC-Web Security Service"};
                      Object selectedValue = JOptionPane.showInputDialog(CapabilityWidget.this,
                              "<html>Aus der URL:<br><pre>" + link + "</pre><br>kann der Servicetyp nicht ermittelt werden.<br><br>Um welchen Service handelt es sich?</html>",
                              "Uups", JOptionPane.INFORMATION_MESSAGE, null, alternatives, alternatives[0]);
--- 191,205 ----
                  }
                  tbpCapabilities.setSelectedComponent(load);
                  // setOGCWMSCapabilitiesTree(link, tbpCapabilities.getComponentCount()-1);
!                 
                  //TODO
!                 
                  if (link.toLowerCase().contains("service=wfs")) {
                      addOGCWFSCapabilitiesTree(link, load, interactive);
!                 } else  if (link.toLowerCase().contains("service=wms")) {
                      addOGCWMSCapabilitiesTree(link, load, interactive, subparent);
                  } else {
!                     Object[] alternatives = {"OGC-Web Mapping Service", "OGC-Web Feature Service"};
                      Object selectedValue = JOptionPane.showInputDialog(CapabilityWidget.this,
                              "<html>Aus der URL:<br><pre>" + link + "</pre><br>kann der Servicetyp nicht ermittelt werden.<br><br>Um welchen Service handelt es sich?</html>",
                              "Uups", JOptionPane.INFORMATION_MESSAGE, null, alternatives, alternatives[0]);
***************
*** 230,252 ****
                          addOGCWMSCapabilitiesTree(link, load, interactive, subparent);
                      } else if (selectedValue == alternatives[1]) {
                          addOGCWFSCapabilitiesTree(link, load, interactive);
-                     } else if (selectedValue == alternatives[2]) {
-                         try {
-                             log.debug("WSS Capabilties Link hinzugefügt");
-                             URL url;
-                             if (link.indexOf('?') != -1) {
-                                 url = new URL(link.substring(0, link.indexOf('?')));
-                             } else {
-                                 url = new URL(link);
-                             }
-                             log.debug("URL des WSS: " + url.toString());
-                             if (!WebAccessManager.getInstance().isHandlerForURLRegistered(url)) {
-                                 WebAccessManager.getInstance().registerAccessHandler(url, AccessHandler.ACCESS_HANDLER_TYPES.WSS);
-                             }
-                             addOGCCapabilitiesTree(link, load, interactive);
-                         } catch (MalformedURLException ex) {
-                             log.error("Url is not wellformed no wss authentication possible", ex);
-                         }
                      } else if (selectedValue == null) {
                          tbpCapabilities.remove(load);
                          capabilityUrls.remove(capabilityUrlsReverse.get(load));
--- 207,212 ----
***************
*** 452,458 ****
          JTree active = getActiveTree();
          if (active != null) {
              log.debug("active = " + active);
-             //ToDo wenn das hier nur bei einem aktivierten Tree gemacht wird kann der link nicht mehr hinzugefügt werden
              LinkWithSubparent link = capabilityUrlsReverse.get(tbpCapabilities.getSelectedComponent());
              capabilityUrls.remove(link);
              capabilityUrlsReverse.remove(tbpCapabilities.getSelectedComponent());
--- 412,417 ----
***************
*** 502,508 ****
      private javax.swing.JToolBar jToolBar1;
      private javax.swing.JTabbedPane tbpCapabilities;
      // End of variables declaration//GEN-END:variables
- 
      /**
       * Liefert den momentan selektierten Capabilties-Baum.
       * @return selektierter Capabilties-Baum
--- 461,466 ----
***************
*** 594,600 ****
                              message,
                              "Error",
                              JOptionPane.ERROR_MESSAGE); //NOI18N
- 
                      return null;
                  }
              }
--- 552,557 ----
***************
*** 694,710 ****
                      OGCWMSCapabilitiesFactory capFact = new OGCWMSCapabilitiesFactory();
                      CismapBroker broker = CismapBroker.getInstance();
                      log.debug("Capability Widget: Creating WMScapabilities for URL: " + getCapURL.toString());
!                     //final WMSCapabilities cap = capFact.createCapabilities(HttpAuthentication.getInputStreamReaderFromURL(CapabilityWidget.this, getCapURL));
!                     final WMSCapabilities cap = capFact.createCapabilities(new InputStreamReader(WebAccessManager.getInstance().doRequest(getCapURL)));
!                     log.debug("finished creating Capabilties");
!                     //TODO for WFS
!                     //ToDo funktionalität abgeschaltet steckt zur zeit in CismetGUICommons --> refactoring
! //                    broker.addHttpCredentialProviderCapabilities(cap, broker.getHttpCredentialProviderURL(getCapURL));
! //                    if (broker.isServerSecuredByPassword(cap)) {
! //                        broker.addProperty(getCapURL.toString(), cap.getCapability().getLayer().getTitle());
! //                    }
                      trvCap.setWmsCapabilities(cap);
                      final WMSCapabilitiesTreeModel tm = new WMSCapabilitiesTreeModel(cap, subparent);
                      DropTarget dt = new DropTarget(trvCap, acceptableActions, thisWidget);
                      EventQueue.invokeLater(new Runnable() {
  
--- 651,665 ----
                      OGCWMSCapabilitiesFactory capFact = new OGCWMSCapabilitiesFactory();
                      CismapBroker broker = CismapBroker.getInstance();
                      log.debug("Capability Widget: Creating WMScapabilities for URL: " + getCapURL.toString());
!                     final WMSCapabilities cap = capFact.createCapabilities(HttpAuthentication.getInputStreamReaderFromURL(CapabilityWidget.this, getCapURL));
!                     broker.addHttpCredentialProviderCapabilities(cap, broker.getHttpCredentialProviderURL(getCapURL));
!                     if (HttpAuthentication.isServerSecuredByPassword(cap)) {
!                         broker.addProperty(getCapURL.toString(), cap.getCapability().getLayer().getTitle());
!                     }
                      trvCap.setWmsCapabilities(cap);
                      final WMSCapabilitiesTreeModel tm = new WMSCapabilitiesTreeModel(cap, subparent);
+ 
+ 
                      DropTarget dt = new DropTarget(trvCap, acceptableActions, thisWidget);
                      EventQueue.invokeLater(new Runnable() {
  
***************
*** 726,733 ****
                              capabilityUrls.put(new LinkWithSubparent(link, subparent), sPane);
                              capabilityUrlsReverse.put(sPane, new LinkWithSubparent(link, subparent));
                              String title = cap.getCapability().getLayer().getTitle().trim();
!                             if (subparent != null) {
!                                 title = subparent;
                              }
                              String titleOrig = title;
                              if (title.length() > 0) {
--- 681,688 ----
                              capabilityUrls.put(new LinkWithSubparent(link, subparent), sPane);
                              capabilityUrlsReverse.put(sPane, new LinkWithSubparent(link, subparent));
                              String title = cap.getCapability().getLayer().getTitle().trim();
!                             if (subparent!=null){
!                                 title=subparent;
                              }
                              String titleOrig = title;
                              if (title.length() > 0) {
***************
*** 746,756 ****
                          }
                      });
                  } catch (Exception e) {
-                     log.error("Fehler währened dem erstellen des WMSCapabilties Baums", e);
                      String message = "";
  
                      tbpCapabilities.setIconAt(tbpCapabilities.indexOfComponent(comp), icoError);
!                     if (e instanceof RequestFailedException || e.getMessage() == null || e.getMessage().equals("null")) {
                          message = e.getCause().getMessage();
                      } else {
                          message = e.getMessage();
--- 701,710 ----
                          }
                      });
                  } catch (Exception e) {
                      String message = "";
  
                      tbpCapabilities.setIconAt(tbpCapabilities.indexOfComponent(comp), icoError);
!                     if (e.getMessage() == null || e.getMessage().equals("null")) {
                          message = e.getCause().getMessage();
                      } else {
                          message = e.getMessage();
***************
*** 776,974 ****
          t.start();
      }
  
-     public void addOGCCapabilitiesTree(final String link, final JComponent comp, final boolean interactive) {
-         log.debug("addOGCCapabilitiesTree()");
-         Thread t = new Thread() {
- 
-             @Override
-             public void run() {
-                 try {
-                     final DragTree trvCap = new DragTree();
-                     //ToDo outsource/generalise method
-                     // URL-String als URL speichern
-                     URL getCapURL = new URL(link);
-                     URL postURL;
- 
-                     // WFSCapabilities aus dem \u00FCbergebenen Link (liefert XML-Dok) parsen
-                     //log.debug("Versuche WFSCapabilities zu parsen");
-                     if (link.indexOf('?') > 0) {
-                         postURL = new URL(link.substring(0, link.indexOf('?')));
-                     } else {
-                         postURL = getCapURL;
-                     }
- 
-                     final URL finalPostUrl = postURL;
- //                    final WFSOperator op = new WFSOperator();
- //                    final WFSCapabilities cap = op.parseWFSCapabilites(postURL);
- //
- //                    // Hashmap mit den FeatureLayer-Attributen erzeugen
- //                    log.debug("Erzeuge WFSCapabilitiesTreeModel");
- //                    final WFSCapabilitiesTreeModel tm = new WFSCapabilitiesTreeModel(cap);
- //                    tm.setFeatureTypes(op.getElements(postURL, cap.getFeatureTypeList()));
- 
-                     // Den WFSTree als DropTarget spezifizieren
-                     //final AbstractCapabilitiesTreeModel capTreeModel = passwordDialog.getCapabilitiesTree();
-                     DropTarget dt = new DropTarget(trvCap, acceptableActions, thisWidget);
- 
- 
-                     final AbstractCapabilitiesTreeModel capTreeModel;
-                     //TODO!!! Wenn beim abrufen der Capabillities der neue Server entfernt wird --> kann er nicht mehr hinzugefügt werden kann
- 
-                     AccessHandler handler = WebAccessManager.getInstance().getHandlerForURL(finalPostUrl);
-                     final String securedServiceType = ((WSSAccessHandler) handler).getSecuredServiceTypeForURL(finalPostUrl);
-                     if (securedServiceType != null) {
-                         log.debug("SecuredServiceType des WSS konnte bestimmt werden: " + securedServiceType);
-                         if (securedServiceType.equals(WSSAccessHandler.SECURED_SERVICE_TYPE.WFS.toString())) {
-                             log.debug("Gesicheter Service ist ein: " + WSSAccessHandler.SECURED_SERVICE_TYPE.WFS);
-                             log.debug("Capability Widget: Creating WFScapabilities for URL: " + finalPostUrl.toString());
-                             InputStream result = WebAccessManager.getInstance().doRequest(finalPostUrl, new StringReader("?REQUEST=GetCapabilities&service=WFS"), AccessHandler.ACCESS_METHODS.GET_REQUEST);
-                             final WFSOperator op = new WFSOperator();
-                             final WFSCapabilities capWFS = op.parseWFSCapabilites(new BufferedReader(new InputStreamReader(result)));
-                             log.debug("Erstelle WFSCapabilitiesTreeModel");
-                             capTreeModel = new WFSCapabilitiesTreeModel(capWFS);
-                             capTreeModel.setServiceName(op.getServiceName());
-                             ((WFSCapabilitiesTreeModel) capTreeModel).setFeatureTypes(op.getElements(finalPostUrl, capWFS.getFeatureTypeList()));
-                         } else if (securedServiceType.equals(WSSAccessHandler.SECURED_SERVICE_TYPE.WMS.toString())) {
-                             log.debug("Gesicheter Service ist ein: " + WSSAccessHandler.SECURED_SERVICE_TYPE.WMS);
-                             try {
-                                 OGCWMSCapabilitiesFactory capFact = new OGCWMSCapabilitiesFactory();
-                                 log.debug("Capability Widget: Creating WMScapabilities for URL: " + finalPostUrl.toString());
-                                 InputStream result = WebAccessManager.getInstance().doRequest(finalPostUrl, new StringReader("REQUEST=GetCapabilities&service=WMS"), AccessHandler.ACCESS_METHODS.GET_REQUEST);
-                                 log.debug("WMS Capabilties erstellt");
-                                 //ToDO Langsam
-                                 final WMSCapabilities capWMS = capFact.createCapabilities(new BufferedReader(new InputStreamReader(result)));
-                                 log.debug("Erstelle WMSCapabilitiesTreeModel");
-                                 capTreeModel = new WMSCapabilitiesTreeModel(capWMS);
-                                 capTreeModel.setServiceName(capWMS.getCapability().getLayer().getTitle().trim());
-                             } catch (Exception ex) {
-                                 log.error("Exception during doRequest cause: ", ex);
-                                 return;
-                             }
-                         } else {
-                             log.debug("Gesicherter Service ist von unbekanntem Typ.");
-                             return;
-                         }
-                     } else {
-                         log.warn("SecuredServiceType des WSS konnte nicht bestimmt werden");
-                         return;
-                     }
- 
-                     // ToDo Listener oder sonstwas damit das retrieval auch abgebrochen wird
-                     if (tbpCapabilities.indexOfComponent(comp) == -1) {
-                         log.info("Ladepanel ist nicht mehr in TabbedPane --> retrieval wird abgebrochen");
-                         LinkWithSubparent link = capabilityUrlsReverse.get(comp);
-                         capabilityUrls.remove(link);
-                         capabilityUrlsReverse.remove(comp);
-                         if (wmsCapabilities.get(comp) != null) {
-                             log.debug("Entferne WMSCapabilities-Tree");
-                             wmsCapabilities.remove(comp);
-                             wmsCapabilitiesTrees.remove(comp);
-                             tbpCapabilities.remove(tbpCapabilities.indexOfComponent(comp));
-                         } else if (wfsCapabilities.get(comp) != null) {
-                             log.debug("Entferne WFSCapabilities-Tree");
-                             wfsCapabilities.remove(comp);
-                             wfsCapabilitiesTrees.remove(comp);
-                             wfsPostUrls.remove(comp);
-                             tbpCapabilities.remove(comp);
-                         } else {
-                             log.warn("Keine Component zum entfernen aktiv");
-                         }
-                         return;
-                     } else {
-                         log.debug("Capabilitespanel noch vorhanden --> stelle baum dar");
-                     }
-                     EventQueue.invokeLater(new Runnable() {
- 
-                         public void run() {
-                             //broker.addHttpCredentialProviderCapabilities(cap, broker.getHttpCredentialProviderURL(url));
-                             //ToDO subparent
- 
-                             String name = capTreeModel.getServiceName();
-                             log.debug("ServiceName: " + name);
-                             trvCap.setModel(capTreeModel);
- 
-                             trvCap.setBorder(new EmptyBorder(
-                                     1, 1, 1, 1));
-                             final JScrollPane sPane = new JScrollPane();
-                             sPane.setViewportView(trvCap);
-                             sPane.setBorder(
-                                     new EmptyBorder(1, 1, 1, 1));
-                             StaticSwingTools.setNiftyScrollBars(sPane);
-                             synchronized (this) {
-                                 tbpCapabilities.setComponentAt(tbpCapabilities.indexOfComponent(comp), sPane);
-                             }
-                             //ToDo generalize --> getCapabilities of AbstractCapabilitiesTreeModel
-                             if (capTreeModel instanceof WMSCapabilitiesTreeModel) {
-                                 log.debug("WMSTree");
-                                 wmsCapabilities.put(sPane, ((WMSCapabilitiesTreeModel) capTreeModel).getCapabilities());
-                                 wmsCapabilitiesTrees.put(sPane, trvCap);
-                                 trvCap.setWmsCapabilities(((WMSCapabilitiesTreeModel) capTreeModel).getCapabilities());
-                                 trvCap.setCellRenderer(new WMSCapabilitiesTreeCellRenderer());
-                                 stateChanged(null);
-                             } else if (capTreeModel instanceof WFSCapabilitiesTreeModel) {
-                                 log.debug("WFSTree");
-                                 wfsCapabilities.put(sPane, ((WFSCapabilitiesTreeModel) capTreeModel).getCapabilities());
-                                 wfsCapabilitiesTrees.put(sPane, trvCap);
-                                 wfsPostUrls.put(sPane, finalPostUrl);
-                                 trvCap.setCellRenderer(new WFSCapabilitiesTreeCellRenderer(name));
-                                 stateChanged(null);
-                             } else {
-                                 //Throw exception
-                             }
- 
-                             capabilityUrls.put(new LinkWithSubparent(link, null), sPane);
-                             capabilityUrlsReverse.put(sPane,
-                                     new LinkWithSubparent(link, null));
-                             String title = name;
-                             String titleOrig = title;
- 
-                             if (title.length() >
-                                     0) {
-                                 if (title.length() > maxServerNameLength) {
-                                     title = title.substring(0, maxServerNameLength - 3) + "...";
-                                 }
-                                 sPane.putClientProperty("tabTitle", title);
-                                 synchronized (this) {
-                                     StaticSwingTools.jTabbedPaneWithVerticalTextSetNewText(tbpCapabilities, title, icoConnected, Color.black, sPane);
-                                 }
-                                 synchronized (this) {
-                                     tbpCapabilities.setToolTipTextAt(tbpCapabilities.indexOfComponent(sPane), titleOrig);
-                                 }
-                                 stateChanged(null);
-                             }
-                         }
-                     });
-                 } catch (Exception e) {
-                     String message = "";
- 
-                     tbpCapabilities.setIconAt(tbpCapabilities.indexOfComponent(comp), icoError);
-                     if (e.getMessage() == null || e.getMessage().equals("null")) {
-                         message = e.getCause().getMessage();
-                     } else {
-                         message = e.getMessage();
-                     }
- 
-                     if (interactive) {
-                         JOptionPane.showMessageDialog(thisWidget,
-                                 ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("CapabilityWidget.Fehler_beim_Laden_der_Capabilities_des_Servers") + " " + message,
-                                 ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("CapabilityWidget.Error"),
-                                 JOptionPane.ERROR_MESSAGE);
-                     }
-                     log.error(ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("CapabilityWidget.Fehler_beim_Laden_der_Capabilities_des_Servers_log") + " " + message, e);
-                     tbpCapabilities.remove(tbpCapabilities.indexOfComponent(comp));
- 
-                     JComponent jc = capabilityUrls.get(link);
-                     capabilityUrls.remove(link);
-                     capabilityUrlsReverse.remove(jc);
-                 }
-             }
-         };
- 
-         t.setPriority(Thread.NORM_PRIORITY);
- 
-         t.start();
-     }
- 
      /**
       * Erzeugt den Baum aus der geparsten Capabilities-XML und f\u00FCgt ihn der 
       * TabbedPane hinzu.
--- 730,735 ----
***************
*** 976,984 ****
       * @param comp Component
       * @param interactive true, falls per Drag&Drop, sonst false
       */
!     private void addOGCWFSCapabilitiesTree(final String link,
!             final JComponent comp,
!             final boolean interactive) {
          log.debug("addOGCWFSCapabilitiesTree()");
          Thread t = new Thread() {
  
--- 737,743 ----
       * @param comp Component
       * @param interactive true, falls per Drag&Drop, sonst false
       */
!     private void addOGCWFSCapabilitiesTree(final String link, final JComponent comp, final boolean interactive) {
          log.debug("addOGCWFSCapabilitiesTree()");
          Thread t = new Thread() {
  
***************
*** 990,996 ****
                      URL getCapURL = new URL(link);
                      URL postURL;
  
! // WFSCapabilities aus dem \u00FCbergebenen Link (liefert XML-Dok) parsen
                      log.debug("Versuche WFSCapabilities zu parsen");
                      if (link.indexOf('?') > 0) {
                          postURL = new URL(link.substring(0, link.indexOf('?')));
--- 749,755 ----
                      URL getCapURL = new URL(link);
                      URL postURL;
  
!                     // WFSCapabilities aus dem \u00FCbergebenen Link (liefert XML-Dok) parsen
                      log.debug("Versuche WFSCapabilities zu parsen");
                      if (link.indexOf('?') > 0) {
                          postURL = new URL(link.substring(0, link.indexOf('?')));
***************
*** 1023,1029 ****
                              synchronized (this) {
                                  tbpCapabilities.setComponentAt(tbpCapabilities.indexOfComponent(comp), sPane);
                              }
- 
                              wfsCapabilities.put(sPane, cap);
                              wfsCapabilitiesTrees.put(sPane, trvCap);
                              wfsPostUrls.put(sPane, finalPostUrl);
--- 782,787 ----
***************
*** 1037,1055 ****
                                  if (title.length() > maxServerNameLength) {
                                      title = title.substring(0, maxServerNameLength - 3) + "...";
                                  }
- 
                                  sPane.putClientProperty("tabTitle", title);
                                  synchronized (this) {
                                      StaticSwingTools.jTabbedPaneWithVerticalTextSetNewText(tbpCapabilities, title, icoConnected, Color.black, sPane);
                                  }
- 
                                  synchronized (this) {
                                      tbpCapabilities.setToolTipTextAt(tbpCapabilities.indexOfComponent(sPane), titleOrig);
                                  }
- 
                                  stateChanged(null);
                              }
- 
                          }
                      });
                  } catch (Exception e) {
--- 795,809 ----
***************
*** 1068,1074 ****
                                  ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("CapabilityWidget.Error"),
                                  JOptionPane.ERROR_MESSAGE);
                      }
- 
                      log.error(ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("CapabilityWidget.Fehler_beim_Laden_der_Capabilities_des_Servers_log") + " " + message, e);
                      tbpCapabilities.remove(tbpCapabilities.indexOfComponent(comp));
  
--- 822,827 ----
***************
*** 1076,1082 ****
                      capabilityUrls.remove(link);
                      capabilityUrlsReverse.remove(jc);
                  }
- 
              }
          };
          t.setPriority(Thread.NORM_PRIORITY);
--- 829,834 ----
***************
*** 1093,1108 ****
              try {
                  tbpCapabilities.setForegroundAt(selectedIndex, null);
                  String t;
! 
!                 t =
!                         (String) ((JComponent) tbpCapabilities.getComponentAt(selectedIndex)).getClientProperty("tabTitle");
                  if (t == null) {
                      t = "";
                  }
- 
                  StaticSwingTools.jTabbedPaneWithVerticalTextSetNewText(tbpCapabilities, t, icoConnected, Color.black, (JComponent) tbpCapabilities.getComponentAt(selectedIndex));
              } catch (Throwable skip) {
!                 // do nothing
              }
          }
          selectedIndex = tbpCapabilities.getSelectedIndex();
--- 845,857 ----
              try {
                  tbpCapabilities.setForegroundAt(selectedIndex, null);
                  String t;
!                 t = (String) ((JComponent) tbpCapabilities.getComponentAt(selectedIndex)).getClientProperty("tabTitle");
                  if (t == null) {
                      t = "";
                  }
                  StaticSwingTools.jTabbedPaneWithVerticalTextSetNewText(tbpCapabilities, t, icoConnected, Color.black, (JComponent) tbpCapabilities.getComponentAt(selectedIndex));
              } catch (Throwable skip) {
!             // do nothing
              }
          }
          selectedIndex = tbpCapabilities.getSelectedIndex();
***************
*** 1111,1121 ****
              if (t == null) {
                  t = "";
              }
- 
              tbpCapabilities.setForegroundAt(selectedIndex, Color.blue);
              StaticSwingTools.jTabbedPaneWithVerticalTextSetNewText(tbpCapabilities, t, icoConnected, Color.blue, (JComponent) tbpCapabilities.getComponentAt(selectedIndex));
          }
- 
          if (wmsCapabilities.get(tbpCapabilities.getSelectedComponent()) != null) {
              CismapBroker.getInstance().fireCapabilityServerChanged(new CapabilityEvent(wmsCapabilities.get(tbpCapabilities.getSelectedComponent())));
          } else if (wfsCapabilities.get(tbpCapabilities.getSelectedComponent()) != null) {
--- 860,868 ----
***************
*** 1124,1130 ****
              log.debug(wmsCapabilities);
              log.debug(wfsCapabilities);
          }
- 
      }
  
      /**
--- 871,876 ----
***************
*** 1142,1148 ****
          //TODO Im Moment gibts nur OGC-WMS Links. Da faul ....
          Element ret = new Element("cismapCapabilitiesPreferences");
          {
- 
              Set wmsCapabilitiesSet = capabilityUrls.keySet();
              Iterator<LinkWithSubparent> it = wmsCapabilitiesSet.iterator();
              LinkWithSubparent selectedLink = capabilityUrlsReverse.get(tbpCapabilities.getSelectedComponent());
--- 888,893 ----
***************
*** 1151,1157 ****
                  CapabilityLink cl = new CapabilityLink(CapabilityLink.OGC, link.getLink(), link.equals(selectedLink), link.getSubparent());
                  ret.addContent(cl.getElement());
              }
- 
          }
          return ret;
      }
--- 896,901 ----
***************
*** 1191,1203 ****
              if (cl.isActive()) {
                  activeComponent = capabilityUrls.get(cl.getLink());
              }
! // TODO Hier WFS, ESRI, Google, ...
! 
          }
          if (activeComponent != null) {
              tbpCapabilities.setSelectedComponent(activeComponent);
          }
- 
          capabilityList.removeAll();
          Iterator<Integer> itList = cp.getCapabilitiesList().keySet().iterator();
          while (itList.hasNext()) {
--- 935,945 ----
              if (cl.isActive()) {
                  activeComponent = capabilityUrls.get(cl.getLink());
              }
!         // TODO Hier WFS, ESRI, Google, ...
          }
          if (activeComponent != null) {
              tbpCapabilities.setSelectedComponent(activeComponent);
          }
          capabilityList.removeAll();
          Iterator<Integer> itList = cp.getCapabilitiesList().keySet().iterator();
          while (itList.hasNext()) {
***************
*** 1209,1216 ****
              } else if (cl.getType().equals(CapabilityLink.SEPARATOR)) {
                  capabilityList.addSeparator();
              }
! // TODO Hier WFS, ESRI, Google, ...
! 
          }
      }
  
--- 951,957 ----
              } else if (cl.getType().equals(CapabilityLink.SEPARATOR)) {
                  capabilityList.addSeparator();
              }
!         // TODO Hier WFS, ESRI, Google, ...
          }
      }
  
***************
*** 1219,1229 ****
       */
      public void removeAllServer() {
          int mx = tbpCapabilities.getTabCount();
!         for (int i = 0; i <
!                 mx; ++i) {
              removeActiveCapabilityTree();
          }
- 
      }
  
      /**
--- 960,968 ----
       */
      public void removeAllServer() {
          int mx = tbpCapabilities.getTabCount();
!         for (int i = 0; i < mx; ++i) {
              removeActiveCapabilityTree();
          }
      }
  
      /**
***************
*** 1234,1241 ****
          ListMenuItem lmi = new ListMenuItem("test", cl);
          lmi.addActionListener(new ActionListener() {
  
!             public void actionPerformed(
!                     ActionEvent e) {
                  addLinkManually(new LinkWithSubparent(cl.getLink(), cl.getSubparent()));
              }
          });
--- 973,979 ----
          ListMenuItem lmi = new ListMenuItem("test", cl);
          lmi.addActionListener(new ActionListener() {
  
!             public void actionPerformed(ActionEvent e) {
                  addLinkManually(new LinkWithSubparent(cl.getLink(), cl.getSubparent()));
              }
          });
***************
*** 1250,1267 ****
          if (t != null) {
              t.repaint();
          }
- 
- 
- 
- 
- 
- 
- 
- 
      }
  
!     class ListMenuItem
!             extends JMenuItem {
  
          private CapabilityLink capabilityLink;
  
--- 988,996 ----
          if (t != null) {
              t.repaint();
          }
      }
  
!     class ListMenuItem extends JMenuItem {
  
          private CapabilityLink capabilityLink;
  
***************
*** 1283,1289 ****
  
          DragSource dragSource = null;
          TreePath[] cachedTreePaths; //DND Fehlverhalten Workaround
- 
          private WMSCapabilities wmsCapabilities;
  
          public DragTree() {
--- 1012,1017 ----
***************
*** 1292,1306 ****
                      this, // component where drag originates
                      DnDConstants.ACTION_COPY_OR_MOVE, // actions
                      this); // drag gesture recognizer
- 
              addMouseListener(new MouseAdapter() {                                       //DND Fehlverhalten Workaround
  
- 
                  @Override
                  public void mouseReleased(MouseEvent e) {                           //DND Fehlverhalten Workaround
- 
                      cachedTreePaths = getSelectionModel().getSelectionPaths();       //DND Fehlverhalten Workaround
- 
                  }
              });
  
--- 1020,1030 ----
***************
*** 1320,1339 ****
  
          public void dragGestureRecognized(DragGestureEvent e) {
              getSelectionModel().setSelectionPaths(cachedTreePaths); //DND Fehlverhalten Workaround
- 
              TreePath selPath = getPathForLocation((int) e.getDragOrigin().getX(), (int) e.getDragOrigin().getY());//DND Fehlverhalten Workaround
  
              if ((e.getTriggerEvent().getModifiers() & (InputEvent.CTRL_MASK | InputEvent.SHIFT_MASK)) != 0) {//DND Fehlverhalten Workaround
- 
                  getSelectionModel().setSelectionPaths(cachedTreePaths); //DND Fehlverhalten Workaround /
- 
                  getSelectionModel().addSelectionPath(selPath);          //DND Fehlverhalten Workaround
- 
                  cachedTreePaths = getSelectionModel().getSelectionPaths();//DND Fehlverhalten Workaround
- 
              } else {
                  getSelectionModel().setSelectionPath(selPath);//DND Fehlverhalten Workaround
- 
              }
  
              Transferable trans = null;
--- 1044,1057 ----
***************
*** 1348,1354 ****
                      String name = "";
                      String id = "";
                      if (element.getChildren().size() == 0) { // Attribut geklickt, mit Parent arbeiten
- 
                          op = new WFSOperator(element.getParent().getAttributeValue("name"));
                          id = element.getAttributeValue("name");
                          element = element.getParent();
--- 1066,1071 ----
Index: de/cismet/cismap/commons/gui/featurecontrolwidget/FeatureControl.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/featurecontrolwidget/FeatureControl.java,v
retrieving revision 1.28
diff -c -r1.28 FeatureControl.java
*** de/cismet/cismap/commons/gui/featurecontrolwidget/FeatureControl.java	8 Jul 2008 13:56:24 -0000	1.28
--- de/cismet/cismap/commons/gui/featurecontrolwidget/FeatureControl.java	19 Mar 2009 14:56:42 -0000
***************
*** 86,95 ****
          //Vorerst: SingleSelection
          //jxtFeatures.setSelectionMode(jxtFeatures.getSelectionModel().SINGLE_SELECTION);
          //jxtFeatures.setAutoCreateColumnsFromModel(true);
!         jxtFeatures.getColumnModel().getColumn(0).setCellRenderer(new JXTable.IconRenderer());
!         jxtFeatures.getColumnModel().getColumn(4).setCellRenderer(new JXTable.NumberRenderer());
!         jxtFeatures.getColumnModel().getColumn(5).setCellRenderer(new JXTable.NumberRenderer());
!         jxtFeatures.getColumnModel().getColumn(7).setCellRenderer(new JXTable.IconRenderer());
          //jxtFeatures.getColumnModel().getColumn(7).setCellEditor(new JXTable.BooleanEditor());
  
          filter = new FeatureCollectionFilter(false);
--- 86,96 ----
          //Vorerst: SingleSelection
          //jxtFeatures.setSelectionMode(jxtFeatures.getSelectionModel().SINGLE_SELECTION);
          //jxtFeatures.setAutoCreateColumnsFromModel(true);
! 
!         jxtFeatures.getColumnModel().getColumn(0).setCellRenderer(jxtFeatures.getDefaultRenderer(Icon.class));
!         jxtFeatures.getColumnModel().getColumn(4).setCellRenderer(jxtFeatures.getDefaultRenderer(Number.class));
!         jxtFeatures.getColumnModel().getColumn(5).setCellRenderer(jxtFeatures.getDefaultRenderer(Number.class));
!         jxtFeatures.getColumnModel().getColumn(7).setCellRenderer(jxtFeatures.getDefaultRenderer(Icon.class));
          //jxtFeatures.getColumnModel().getColumn(7).setCellEditor(new JXTable.BooleanEditor());
  
          filter = new FeatureCollectionFilter(false);
***************
*** 98,103 ****
--- 99,105 ----
          jxtFeatures.setFilters(filters);
          //jxtFeatures.setHighlighters(new HighlighterPipeline(new Highlighter[]{ AlternateRowHighlighter.classicLinePrinter }));
          jxtFeatures.getSelectionModel().addListSelectionListener(theListSelectionListener);
+ 
      }
  
      /** This method is called from within the constructor to
Index: de/cismet/cismap/commons/gui/infowidgets/Legend.form
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/infowidgets/Legend.form,v
retrieving revision 1.5
retrieving revision 1.6
diff -c -r1.5 -r1.6
*** de/cismet/cismap/commons/gui/infowidgets/Legend.form	5 Oct 2006 08:32:17 -0000	1.5
--- de/cismet/cismap/commons/gui/infowidgets/Legend.form	2 Dec 2008 16:18:14 -0000	1.6
***************
*** 1,6 ****
  <?xml version="1.0" encoding="UTF-8" ?>
  
! <Form version="1.0" type="org.netbeans.modules.form.forminfo.JPanelFormInfo">
    <NonVisualComponents>
      <Container class="javax.swing.JScrollPane" name="scpLegends">
        <Properties>
--- 1,6 ----
  <?xml version="1.0" encoding="UTF-8" ?>
  
! <Form version="1.4" maxVersion="1.4" type="org.netbeans.modules.form.forminfo.JPanelFormInfo">
    <NonVisualComponents>
      <Container class="javax.swing.JScrollPane" name="scpLegends">
        <Properties>
***************
*** 40,46 ****
--- 40,48 ----
      </Property>
    </Properties>
    <AuxValues>
+     <AuxValue name="FormSettings_autoSetComponentName" type="java.lang.Boolean" value="false"/>
      <AuxValue name="FormSettings_formBundle" type="java.lang.String" value="de/cismet/cismap/commons/GuiBundle"/>
+     <AuxValue name="FormSettings_generateFQN" type="java.lang.Boolean" value="true"/>
      <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
      <AuxValue name="FormSettings_i18nAutoMode" type="java.lang.Boolean" value="true"/>
      <AuxValue name="FormSettings_layoutCodeTarget" type="java.lang.Integer" value="2"/>
Index: de/cismet/cismap/commons/gui/infowidgets/Legend.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/infowidgets/Legend.java,v
retrieving revision 1.14
retrieving revision 1.16
diff -c -r1.14 -r1.16
*** de/cismet/cismap/commons/gui/infowidgets/Legend.java	20 May 2008 13:18:48 -0000	1.14
--- de/cismet/cismap/commons/gui/infowidgets/Legend.java	2 Dec 2008 16:18:36 -0000	1.16
***************
*** 3,9 ****
   *
   * Created on 16. Februar 2006, 13:59
   */
- 
  package de.cismet.cismap.commons.gui.infowidgets;
  
  import de.cismet.cismap.commons.interaction.ActiveLayerListener;
--- 3,8 ----
***************
*** 40,227 ****
   * @author  thorsten.hell@cismet.de
   */
  public class Legend extends javax.swing.JPanel implements ActiveLayerListener {
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
!     
!     private HashMap<String,WMSCapabilities> wmsCapabilities = new HashMap<String,WMSCapabilities>();
!     private LegendModel tableModel=new LegendModel();
!     
!     
      /** Creates new form Legend */
      public Legend() {
          initComponents();
          this.setLayout(new BorderLayout());
!         
          tblLegends.setModel(tableModel);
          tblLegends.setTableHeader(null);
          //tblLegends.getColumnModel().getColumn(0).setCellRenderer(new CustomCellRenderer());
!         tblLegends.setDefaultRenderer(LegendPanel.class,new CustomCellRenderer());
          tblLegends.setShowHorizontalLines(false);
!         tblLegends.setBorder(new EmptyBorder(0,0,0,0));
!         
          //scpLegends
          //scpLegends.setBorder(new EmptyBorder(0,0,0,0));
          tblLegends.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
!         
          //scpLegends.setSize(this.getSize());
          tblLegends.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
!         
          //    tblLegends.setPreferredScrollableViewportSize(new Dimension(1000,1000));
  //        tblLegends.revalidate();
!         scpLegends=new JScrollPane(tblLegends);
          //scpLegends.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
          StaticSwingTools.setNiftyScrollBars(scpLegends);
!         add(scpLegends,BorderLayout.CENTER);
!         //tblLegends.setPreferredSize(Width(600);
!         
!         
!     }
!     
!     public void addLegend(String url) {
!         LegendPanel lp=new LegendPanel(url);
!         tableModel.addLegend(url);
!     }
!     
!     public void removeLegend(String url) {
!         tableModel.getAllUrls().remove(url);
!         if (!tableModel.getAllUrls().contains(url)) {
!             tableModel.getAllUrls().add(url);//wird nochmal entfernt
!             tableModel.removeLegend(url);
!         }
      }
!     
      public void scrollToLegend(String url) {
!         int pos=tableModel.getPosition(url);
!         if (pos!=-1) {
!             StaticSwingTools.jTableScrollToVisible(tblLegends,pos,0);
              log.debug(tblLegends.getSelectionModel().getValueIsAdjusting());
              if (!tblLegends.getSelectionModel().isSelectedIndex(pos)) {
!                 tblLegends.getSelectionModel().setSelectionInterval(pos,pos);
              }
          } else {
              tblLegends.getSelectionModel().clearSelection();
          }
      }
!     
!     
!     
!     public static void main(String []args) {
          try {
              org.apache.log4j.PropertyConfigurator.configure(ClassLoader.getSystemResource("de/cismet/cismap/commons/demo/log4j.properties"));
          } catch (Exception e) {
              e.printStackTrace();
          }
!         
!         JFrame f=new JFrame();
          f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
!         Legend l=new Legend();
          f.getContentPane().setLayout(new BorderLayout());
!         f.getContentPane().add(l,BorderLayout.CENTER);
!         l.addLegend("http://www.google.de/logos/olympics06_speedskating.gif");
!         l.addLegend("http://www.google.de/logos/olympics06_ski_jump.gif");
!         l.addLegend("http://www.google.de/logos/olympics06_curling.gif");
!         l.addLegend("http://www.google.de/logos/olympics06_speedskating.gif");
!         f.setSize(100,400);
          f.setVisible(true);
!         
      }
!     
      public void layerVisibilityChanged(ActiveLayerEvent e) {
-         
      }
!     
!     
      public void layerRemoved(ActiveLayerEvent e) {
          log.debug("layerRemoved() fired");
          if (e.getLayer() instanceof WMSServiceLayer) {
!             WMSServiceLayer wmsLayer=(WMSServiceLayer)e.getLayer();
!             Vector v=wmsLayer.getWMSLayers();
!             Iterator it=v.iterator();
              while (it.hasNext()) {
                  Object elem = (Object) it.next();
                  if (elem instanceof WMSLayer) {
!                     WMSLayer wl=(WMSLayer)elem;
                      removeWMSLayer(wl);
                  }
              }
          } else if (e.getLayer() instanceof WMSLayer) {
!             removeWMSLayer((WMSLayer)e.getLayer());
          } else {
!             log.warn(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.von_diesem_Typ_kann_keine_Legende_erstellt_werden")+ e.getLayer() );
          }
      }
!     
!     private void removeWMSLayer(WMSLayer wl)  {
!         String title=wl.getOgcCapabilitiesLayer().getTitle();
!         String url=null;
          try {
!             LegendURL[] lua=wl.getSelectedStyle().getLegendURL();
!             url=lua[0].getOnlineResource().toString();
          } catch (Throwable t) {
!             log.debug(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.konnte_fuer_")+title+java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.keine_Legende_finden."),t);
          }
!         if (url!=null) {
!             this.removeLegend(url);
          }
      }
!     
      public void layerSelectionChanged(ActiveLayerEvent e) {
          log.debug("layerSelectionChanged() fired");
!         if (e.getLayer() instanceof WMSLayer||e.getLayer() instanceof WMSServiceLayer ) {
!             WMSLayer layer=null;
              if (e.getLayer() instanceof WMSLayer) {
!                 layer=(WMSLayer)e.getLayer();
!             } else if (e.getLayer() instanceof WMSServiceLayer && ((WMSServiceLayer)e.getLayer()).getWMSLayers().size()==1 ) {
!                 layer=(WMSLayer)((WMSServiceLayer)e.getLayer()).getWMSLayers().get(0);
              }
              try {
                  scrollToLegend(layer.getSelectedStyle().getLegendURL()[0].getOnlineResource().toString());
              } catch (Exception ex) {
!                 log.debug(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.Kann_nicht_zur_Legende_von_")+e.getLayer() +java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.scrollen"),ex);
              }
          }
      }
!     
      public void layerPositionChanged(ActiveLayerEvent e) {
          log.debug("layerPositionChanged() fired");
      }
!     
      public void layerAdded(ActiveLayerEvent e) {
          log.debug("layerAdded() fired");
!         
          if (e.getLayer() instanceof WMSServiceLayer) {
!             WMSServiceLayer wmsLayer=(WMSServiceLayer)e.getLayer();
!             Vector v=wmsLayer.getWMSLayers();
!             Iterator it=v.iterator();
              while (it.hasNext()) {
                  Object elem = (Object) it.next();
                  if (elem instanceof WMSLayer) {
!                     WMSLayer wl=(WMSLayer)elem;
!                     String title=wl.getOgcCapabilitiesLayer().getTitle();
!                     String url=null;
                      try {
!                         LegendURL[] lua=wl.getSelectedStyle().getLegendURL();
!                         url=lua[0].getOnlineResource().toString();
                      } catch (Throwable t) {
!                         log.debug(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.konnte_fuer")+title+java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.keine_Legende_finden"),t);
                      }
!                     if (url!=null) {
!                         wmsCapabilities.put(url,wmsLayer.getWmsCapabilities());
!                         this.addLegend(url);
                      }
                  }
              }
          } else {
!             log.warn(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.von_diesem_Typ_kann_keine_Legende_erstellt_werden")+ e.getLayer() );
          }
      }
!     
!     
!     
      public void layerInformationStatusChanged(ActiveLayerEvent e) {
      }
!     
!     
!     
      /** This method is called from within the constructor to
       * initialize the form.
       * WARNING: Do NOT modify this code. The content of this method is
--- 39,222 ----
   * @author  thorsten.hell@cismet.de
   */
  public class Legend extends javax.swing.JPanel implements ActiveLayerListener {
+ 
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
!     private HashMap<String, WMSCapabilities> wmsCapabilities = new HashMap<String, WMSCapabilities>();
!     private LegendModel tableModel = new LegendModel();
! 
      /** Creates new form Legend */
      public Legend() {
          initComponents();
          this.setLayout(new BorderLayout());
! 
          tblLegends.setModel(tableModel);
          tblLegends.setTableHeader(null);
          //tblLegends.getColumnModel().getColumn(0).setCellRenderer(new CustomCellRenderer());
!         tblLegends.setDefaultRenderer(LegendPanel.class, new CustomCellRenderer());
          tblLegends.setShowHorizontalLines(false);
!         tblLegends.setBorder(new EmptyBorder(0, 0, 0, 0));
! 
          //scpLegends
          //scpLegends.setBorder(new EmptyBorder(0,0,0,0));
          tblLegends.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
! 
          //scpLegends.setSize(this.getSize());
          tblLegends.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
! 
          //    tblLegends.setPreferredScrollableViewportSize(new Dimension(1000,1000));
  //        tblLegends.revalidate();
!         scpLegends = new JScrollPane(tblLegends);
          //scpLegends.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
          StaticSwingTools.setNiftyScrollBars(scpLegends);
!         add(scpLegends, BorderLayout.CENTER);
!     //tblLegends.setPreferredSize(Width(600);
! 
! 
!     }
! 
!     public void addLegend(String url, String layername) {
!         LegendPanel lp = new LegendPanel(url);
!         tableModel.addLegend(url, layername);
      }
! 
!     public void removeLegendByName(String layername) {
! //bizarr
! //        tableModel.getAllUrls().remove(url);
! //        if (!tableModel.getAllUrls().contains(url)) {
! //            tableModel.getAllUrls().add(url);//wird nochmal entfernt
! //            tableModel.removeLegend(url);
! //        }
!         tableModel.removeLegendByName(layername);
!     }
! 
      public void scrollToLegend(String url) {
!         int pos = tableModel.getPosition(url);
!         if (pos != -1) {
!             StaticSwingTools.jTableScrollToVisible(tblLegends, pos, 0);
              log.debug(tblLegends.getSelectionModel().getValueIsAdjusting());
              if (!tblLegends.getSelectionModel().isSelectedIndex(pos)) {
!                 tblLegends.getSelectionModel().setSelectionInterval(pos, pos);
              }
          } else {
              tblLegends.getSelectionModel().clearSelection();
          }
      }
! 
!     public static void main(String[] args) {
          try {
              org.apache.log4j.PropertyConfigurator.configure(ClassLoader.getSystemResource("de/cismet/cismap/commons/demo/log4j.properties"));
          } catch (Exception e) {
              e.printStackTrace();
          }
! 
!         JFrame f = new JFrame();
          f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
!         Legend l = new Legend();
          f.getContentPane().setLayout(new BorderLayout());
!         f.getContentPane().add(l, BorderLayout.CENTER);
!         l.addLegend("http://www.google.de/logos/olympics06_speedskating.gif", "1");
!         l.addLegend("http://www.google.de/logos/olympics06_ski_jump.gif", "2");
!         l.addLegend("http://www.google.de/logos/olympics06_curling.gif", "3");
!         l.addLegend("http://www.google.de/logos/olympics06_speedskating.gif", "4");
!         f.setSize(100, 400);
          f.setVisible(true);
! 
      }
! 
      public void layerVisibilityChanged(ActiveLayerEvent e) {
      }
! 
      public void layerRemoved(ActiveLayerEvent e) {
          log.debug("layerRemoved() fired");
          if (e.getLayer() instanceof WMSServiceLayer) {
!             WMSServiceLayer wmsLayer = (WMSServiceLayer) e.getLayer();
!             Vector v = wmsLayer.getWMSLayers();
!             Iterator it = v.iterator();
              while (it.hasNext()) {
                  Object elem = (Object) it.next();
                  if (elem instanceof WMSLayer) {
!                     WMSLayer wl = (WMSLayer) elem;
                      removeWMSLayer(wl);
                  }
              }
          } else if (e.getLayer() instanceof WMSLayer) {
!             removeWMSLayer((WMSLayer) e.getLayer());
          } else {
!             log.warn(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.von_diesem_Typ_kann_keine_Legende_erstellt_werden") + e.getLayer());
          }
      }
! 
!     private void removeWMSLayer(WMSLayer wl) {
!         String title = wl.getOgcCapabilitiesLayer().getTitle();
!         String name = wl.getOgcCapabilitiesLayer().getName();
!         String url = null;
          try {
!             LegendURL[] lua = wl.getSelectedStyle().getLegendURL();
!             url = lua[0].getOnlineResource().toString();
          } catch (Throwable t) {
!             log.debug(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.konnte_fuer_") + title + java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.keine_Legende_finden."), t);
          }
!         if (url != null) {
!             this.removeLegendByName(name);
          }
      }
! 
      public void layerSelectionChanged(ActiveLayerEvent e) {
          log.debug("layerSelectionChanged() fired");
!         if (e.getLayer() instanceof WMSLayer || e.getLayer() instanceof WMSServiceLayer) {
!             WMSLayer layer = null;
              if (e.getLayer() instanceof WMSLayer) {
!                 layer = (WMSLayer) e.getLayer();
!             } else if (e.getLayer() instanceof WMSServiceLayer && ((WMSServiceLayer) e.getLayer()).getWMSLayers().size() == 1) {
!                 layer = (WMSLayer) ((WMSServiceLayer) e.getLayer()).getWMSLayers().get(0);
              }
              try {
                  scrollToLegend(layer.getSelectedStyle().getLegendURL()[0].getOnlineResource().toString());
              } catch (Exception ex) {
!                 log.debug(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.Kann_nicht_zur_Legende_von_") + e.getLayer() + java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.scrollen"), ex);
              }
          }
      }
! 
      public void layerPositionChanged(ActiveLayerEvent e) {
          log.debug("layerPositionChanged() fired");
      }
! 
      public void layerAdded(ActiveLayerEvent e) {
          log.debug("layerAdded() fired");
! 
          if (e.getLayer() instanceof WMSServiceLayer) {
!             WMSServiceLayer wmsLayer = (WMSServiceLayer) e.getLayer();
!             Vector v = wmsLayer.getWMSLayers();
!             Iterator it = v.iterator();
              while (it.hasNext()) {
                  Object elem = (Object) it.next();
                  if (elem instanceof WMSLayer) {
!                     WMSLayer wl = (WMSLayer) elem;
!                     String title = wl.getOgcCapabilitiesLayer().getTitle();
!                     String name = wl.getOgcCapabilitiesLayer().getName();
!                     String url = null;
                      try {
!                         LegendURL[] lua = wl.getSelectedStyle().getLegendURL();
!                         url = lua[0].getOnlineResource().toString();
                      } catch (Throwable t) {
!                         log.debug(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.konnte_fuer") + title + java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.keine_Legende_finden"), t);
                      }
!                     if (url != null) {
!                         wmsCapabilities.put(url, wmsLayer.getWmsCapabilities());
!                         this.addLegend(url, name);
!                         log.debug("added legend:" + name + "=" + url);
                      }
                  }
              }
          } else {
!             log.warn(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.von_diesem_Typ_kann_keine_Legende_erstellt_werden") + e.getLayer());
          }
      }
! 
      public void layerInformationStatusChanged(ActiveLayerEvent e) {
      }
! 
      /** This method is called from within the constructor to
       * initialize the form.
       * WARNING: Do NOT modify this code. The content of this method is
***************
*** 250,279 ****
  
          setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 1, 5, 1));
      }// </editor-fold>//GEN-END:initComponents
-     
-     
      // Variables declaration - do not modify//GEN-BEGIN:variables
      private javax.swing.JScrollPane scpLegends;
      private javax.swing.JTable tblLegends;
      // End of variables declaration//GEN-END:variables
!     private int maxWidth=0;
      private class LegendPanel extends JPanel implements RetrievalListener {
!         private String url="";
!         
!         JLabel lblImage=new JLabel();
          public LegendPanel() {
              super();
!             setBorder(new EmptyBorder(2,2,2,2));
!             
              setLayout(new BorderLayout());
!             
!             add(lblImage,BorderLayout.CENTER);
              lblImage.setHorizontalAlignment(JLabel.LEADING);
              lblImage.setVerticalAlignment(JLabel.CENTER);
          }
          public LegendPanel(String url) {
              this();
!             ImageRetrieval ir=new ImageRetrieval(this);
              ir.setUrl(url);
              ir.setWMSCapabilities(wmsCapabilities.get(url));
              ir.setPriority(Thread.NORM_PRIORITY);
--- 245,275 ----
  
          setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 1, 5, 1));
      }// </editor-fold>//GEN-END:initComponents
      // Variables declaration - do not modify//GEN-BEGIN:variables
      private javax.swing.JScrollPane scpLegends;
      private javax.swing.JTable tblLegends;
      // End of variables declaration//GEN-END:variables
!     private int maxWidth = 0;
! 
      private class LegendPanel extends JPanel implements RetrievalListener {
! 
!         private String url = "";
!         JLabel lblImage = new JLabel();
! 
          public LegendPanel() {
              super();
!             setBorder(new EmptyBorder(2, 2, 2, 2));
! 
              setLayout(new BorderLayout());
! 
!             add(lblImage, BorderLayout.CENTER);
              lblImage.setHorizontalAlignment(JLabel.LEADING);
              lblImage.setVerticalAlignment(JLabel.CENTER);
          }
+ 
          public LegendPanel(String url) {
              this();
!             ImageRetrieval ir = new ImageRetrieval(this);
              ir.setUrl(url);
              ir.setWMSCapabilities(wmsCapabilities.get(url));
              ir.setPriority(Thread.NORM_PRIORITY);
***************
*** 281,323 ****
              this.setUrl(url);
  //            this.setMinimumSize(new Dimension(tblLegends.getColumnModel().getColumn(0).getPreferredWidth(),20));
          }
!         
          public void retrievalStarted(RetrievalEvent e) {
              lblImage.setIcon(null);
              lblImage.setText("...");
!             if (maxWidth>0) {
                  tblLegends.getColumnModel().getColumn(0).setPreferredWidth(maxWidth);
              }
              tableModel.fireTableDataChanged();
!             
          }
!         
          public void retrievalProgress(RetrievalEvent e) {
-             
          }
!         
          public void retrievalError(RetrievalEvent e) {
              lblImage.setText("");
              log.error(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.Fehler_beim_Laden_der_Legende"));
              tableModel.fireTableDataChanged();
!                
          }
!         
          public void retrievalComplete(RetrievalEvent e) {
!             if (e.getRetrievedObject() instanceof  Image ) {
!                 Image image=(Image)e.getRetrievedObject();
!                 ImageIcon ii=new ImageIcon(image);
                  lblImage.setText("");
                  lblImage.setIcon(ii);
                  //setSize(new java.awt.Dimension(image.getWidth(null),image.getHeight(null)));
!                 
                  tableModel.fireTableDataChanged();
!                 int newWidth=image.getWidth(null);
!                 if (newWidth<tblLegends.getPreferredSize().width) {
!                     newWidth=tblLegends.getPreferredSize().width;
!                 }
!                 else {
!                     maxWidth=newWidth;
                  }
                  tblLegends.getColumnModel().getColumn(0).setPreferredWidth(newWidth);
  //                tblLegends.setSize(newWidth,1000);
--- 277,317 ----
              this.setUrl(url);
  //            this.setMinimumSize(new Dimension(tblLegends.getColumnModel().getColumn(0).getPreferredWidth(),20));
          }
! 
          public void retrievalStarted(RetrievalEvent e) {
              lblImage.setIcon(null);
              lblImage.setText("...");
!             if (maxWidth > 0) {
                  tblLegends.getColumnModel().getColumn(0).setPreferredWidth(maxWidth);
              }
              tableModel.fireTableDataChanged();
! 
          }
! 
          public void retrievalProgress(RetrievalEvent e) {
          }
! 
          public void retrievalError(RetrievalEvent e) {
              lblImage.setText("");
              log.error(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("Legend.log.Fehler_beim_Laden_der_Legende"));
              tableModel.fireTableDataChanged();
! 
          }
! 
          public void retrievalComplete(RetrievalEvent e) {
!             if (e.getRetrievedObject() instanceof Image) {
!                 Image image = (Image) e.getRetrievedObject();
!                 ImageIcon ii = new ImageIcon(image);
                  lblImage.setText("");
                  lblImage.setIcon(ii);
                  //setSize(new java.awt.Dimension(image.getWidth(null),image.getHeight(null)));
! 
                  tableModel.fireTableDataChanged();
!                 int newWidth = image.getWidth(null);
!                 if (newWidth < tblLegends.getPreferredSize().width) {
!                     newWidth = tblLegends.getPreferredSize().width;
!                 } else {
!                     maxWidth = newWidth;
                  }
                  tblLegends.getColumnModel().getColumn(0).setPreferredWidth(newWidth);
  //                tblLegends.setSize(newWidth,1000);
***************
*** 326,356 ****
  //                
              }
          }
!         
          public void retrievalAborted(RetrievalEvent e) {
              lblImage.setText("");
          }
!         
!         
          public String getUrl() {
              return url;
          }
!         
          public void setUrl(String url) {
              this.url = url;
          }
!         
!         
          public boolean equals(Object tester) {
              if (tester instanceof LegendPanel) {
!                 LegendPanel t=(LegendPanel)tester;
                  return t.url.equals(url);
              } else {
                  return false;
              }
          }
      }
!     private class CustomCellRenderer implements TableCellRenderer{
          /**
           *  Returns the component used for drawing the cell.  This method is
           *  used to configure the renderer appropriately before drawing.
--- 320,350 ----
  //                
              }
          }
! 
          public void retrievalAborted(RetrievalEvent e) {
              lblImage.setText("");
          }
! 
          public String getUrl() {
              return url;
          }
! 
          public void setUrl(String url) {
              this.url = url;
          }
! 
          public boolean equals(Object tester) {
              if (tester instanceof LegendPanel) {
!                 LegendPanel t = (LegendPanel) tester;
                  return t.url.equals(url);
              } else {
                  return false;
              }
          }
      }
! 
!     private class CustomCellRenderer implements TableCellRenderer {
! 
          /**
           *  Returns the component used for drawing the cell.  This method is
           *  used to configure the renderer appropriately before drawing.
***************
*** 378,384 ****
           * @param column	        the column index of the cell being drawn
           */
          public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
!             Component component = (Component)value;
              if (isSelected) {
                  component.setBackground(Color.white);//javax.swing.UIManager.getDefaults().getColor("Table.highlight"));
                  component.setForeground(Legend.this.getForeground());
--- 372,378 ----
           * @param column	        the column index of the cell being drawn
           */
          public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
!             Component component = (Component) value;
              if (isSelected) {
                  component.setBackground(Color.white);//javax.swing.UIManager.getDefaults().getColor("Table.highlight"));
                  component.setForeground(Legend.this.getForeground());
***************
*** 386,454 ****
                  component.setBackground(Legend.this.getBackground());
                  component.setForeground(Legend.this.getForeground());
              }
!             
!             if (table.getRowHeight(row)!=(int)component.getPreferredSize().getHeight()) {
!                 table.setRowHeight(row,(int)component.getPreferredSize().getHeight());
              }
!             
              return component;
          }
-         
      }
      private class LegendModel extends AbstractTableModel {
          //private LinkedHashMap<String,LegendPanel> panels=new LinkedHashMap<String,LegendPanel>();
!         private Vector<LegendPanel> panels=new Vector<LegendPanel>();
!         private HashMap<String,LegendPanel> panelsByUrl=new HashMap<String,LegendPanel>();
!         private Vector<String> allUrls=new Vector();
          public Class<?> getColumnClass(int columnIndex) {
              return LegendPanel.class;
          }
!         
!         
          public int getRowCount() {
              return panels.size();
          }
!         
          public Object getValueAt(int row, int column) {
!             return panels.get(panels.size()-1-row);
          }
!         
          public int getColumnCount() {
              return 1;
          }
!         
!         public void addLegend(String url) {
!             LegendPanel lp=new LegendPanel(url);
!             allUrls.add(url);
              if (!panels.contains(lp)) {
                  panels.add(lp);
!                 panelsByUrl.put(url,lp);
              }
              super.fireTableStructureChanged();
          }
!         
!         public void removeLegend(String url) {
!             allUrls.remove(url);
!             LegendPanel lp=new LegendPanel(url);
!             int index=panels.indexOf(lp);
!             if (index!=-1) {
!                 panels.remove(new LegendPanel(url));
!                 super.fireTableRowsDeleted(index,index);
              }
          }
          public boolean isCellEditable(int row, int column) {
              return false;
          }
!         
          public int getPosition(String url) {
!             LegendPanel lp=panelsByUrl.get(url);
!             
!             return panels.size()-1-panels.indexOf(lp);
!         }
!         
!         public Vector<String> getAllUrls() {
!             return allUrls;
          }
!         
      }
  }
--- 380,455 ----
                  component.setBackground(Legend.this.getBackground());
                  component.setForeground(Legend.this.getForeground());
              }
! 
!             if (table.getRowHeight(row) != (int) component.getPreferredSize().getHeight()) {
!                 table.setRowHeight(row, (int) component.getPreferredSize().getHeight());
              }
! 
              return component;
          }
      }
+ 
      private class LegendModel extends AbstractTableModel {
          //private LinkedHashMap<String,LegendPanel> panels=new LinkedHashMap<String,LegendPanel>();
! 
!         private Vector<LegendPanel> panels = new Vector<LegendPanel>();
!         private HashMap<String, LegendPanel> panelsByName = new HashMap<String, LegendPanel>();
!         private HashMap<String, LegendPanel> panelsByUrl = new HashMap<String, LegendPanel>();
!         private HashMap<String, String> urlsByName = new HashMap<String, String>();
! 
          public Class<?> getColumnClass(int columnIndex) {
              return LegendPanel.class;
          }
! 
          public int getRowCount() {
              return panels.size();
          }
! 
          public Object getValueAt(int row, int column) {
!             return panels.get(panels.size() - 1 - row);
          }
! 
          public int getColumnCount() {
              return 1;
          }
! 
!         public void addLegend(String url, String name) {
!             LegendPanel lp = new LegendPanel(url);
!             urlsByName.put(name, url);
              if (!panels.contains(lp)) {
                  panels.add(lp);
!                 panelsByName.put(name, lp);
!                 panelsByUrl.put(url, lp);
              }
              super.fireTableStructureChanged();
          }
! 
!         public void removeLegendByName(String name) {
!             String url = urlsByName.get(name);
!             urlsByName.remove(name);
!             if (!urlsByName.containsValue(url)) {
!                 LegendPanel lp = new LegendPanel(url);
!                 int index = panels.indexOf(lp);
!                 if (index != -1) {
!                     panels.remove(new LegendPanel(url));
!                     panelsByName.remove(name);
!                     panelsByUrl.remove(url);
!                     super.fireTableRowsDeleted(index, index);
!                 }
              }
          }
+ 
          public boolean isCellEditable(int row, int column) {
              return false;
          }
! 
          public int getPosition(String url) {
!             LegendPanel lp = panelsByUrl.get(url);
! 
!             return panels.size() - 1 - panels.indexOf(lp);
          }
! //        public Vector<String> getAllUrls() {
! //            return urlsByName.;
! //        }
      }
  }
Index: de/cismet/cismap/commons/gui/layerwidget/ActiveLayerModel.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/layerwidget/ActiveLayerModel.java,v
retrieving revision 1.46.6.2
diff -c -r1.46.6.2 ActiveLayerModel.java
*** de/cismet/cismap/commons/gui/layerwidget/ActiveLayerModel.java	9 Oct 2008 12:08:02 -0000	1.46.6.2
--- de/cismet/cismap/commons/gui/layerwidget/ActiveLayerModel.java	19 Mar 2009 14:56:42 -0000
***************
*** 48,64 ****
  import javax.swing.event.TableModelEvent;
  import javax.swing.event.TableModelListener;
  import de.cismet.cismap.commons.RetrievalServiceLayer;
  import de.cismet.cismap.commons.features.DefaultWFSFeature;
  import de.cismet.cismap.commons.featureservice.SimplePostgisFeatureService;
  import de.cismet.cismap.commons.featureservice.SimpleUpdateablePostgisFeatureService;
  import de.cismet.cismap.commons.featureservice.WFSOperator;
  import de.cismet.cismap.commons.featureservice.WebFeatureService;
  import de.cismet.cismap.commons.gui.piccolo.FeatureAnnotationSymbol;
  import de.cismet.cismap.commons.interaction.CismapBroker;
  import de.cismet.cismap.commons.interaction.events.ActiveLayerEvent;
  import de.cismet.cismap.commons.raster.wms.WMSServiceLayer;
  import de.cismet.cismap.commons.raster.wms.simple.SimpleWMS;
! import de.cismet.security.WebAccessManager;
  import de.cismet.tools.StaticXMLTools;
  import de.cismet.tools.configuration.Configurable;
  import de.cismet.tools.configuration.NoWriteError;
--- 48,67 ----
  import javax.swing.event.TableModelEvent;
  import javax.swing.event.TableModelListener;
  import de.cismet.cismap.commons.RetrievalServiceLayer;
+ import de.cismet.cismap.commons.exceptions.AuthenticationCanceledException;
  import de.cismet.cismap.commons.features.DefaultWFSFeature;
  import de.cismet.cismap.commons.featureservice.SimplePostgisFeatureService;
  import de.cismet.cismap.commons.featureservice.SimpleUpdateablePostgisFeatureService;
  import de.cismet.cismap.commons.featureservice.WFSOperator;
  import de.cismet.cismap.commons.featureservice.WebFeatureService;
  import de.cismet.cismap.commons.gui.piccolo.FeatureAnnotationSymbol;
+ import de.cismet.cismap.commons.gui.printing.PrintingWidget;
  import de.cismet.cismap.commons.interaction.CismapBroker;
  import de.cismet.cismap.commons.interaction.events.ActiveLayerEvent;
  import de.cismet.cismap.commons.raster.wms.WMSServiceLayer;
+ import de.cismet.cismap.commons.raster.wms.featuresupportlayer.SimpleFeatureSupportingRasterLayer;
  import de.cismet.cismap.commons.raster.wms.simple.SimpleWMS;
! import de.cismet.cismap.commons.rasterservice.HttpAuthentication;
  import de.cismet.tools.StaticXMLTools;
  import de.cismet.tools.configuration.Configurable;
  import de.cismet.tools.configuration.NoWriteError;
***************
*** 67,74 ****
  import java.awt.Color;
  import java.awt.EventQueue;
  import java.awt.Image;
- import java.io.BufferedReader;
- import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.net.URL;
  import java.util.HashMap;
--- 70,75 ----
***************
*** 77,85 ****
--- 78,89 ----
  import java.util.Vector;
  import java.util.concurrent.BrokenBarrierException;
  import java.util.concurrent.CyclicBarrier;
+ import java.util.logging.Level;
  import javax.swing.tree.TreePath;
  import org.deegree.services.wms.capabilities.WMSCapabilities;
  import org.deegree_impl.services.wms.capabilities.OGCWMSCapabilitiesFactory;
+ import org.jdesktop.swingx.JXErrorPane;
+ import org.jdesktop.swingx.error.ErrorInfo;
  import org.jdom.Element;
  
  /**
***************
*** 126,132 ****
       * @param layer neuer RetrievalServiceLayer
       */
      public synchronized void addLayer(RetrievalServiceLayer layer) {
-         log.debug("addLayer");
          if (layers.contains(layer)) {
              throw new IllegalArgumentException("schon vorhanden");
          }
--- 130,135 ----
***************
*** 148,154 ****
              }
              ((WMSServiceLayer) layer).setSrs(srs);
          }
- 
          layer.addRetrievalListener(new RetrievalListener() {
  
              public void retrievalStarted(RetrievalEvent e) {
--- 151,156 ----
***************
*** 207,216 ****
          if (layer instanceof MapService) {
              fireMapServiceAdded(((MapService) layer));
          }
!         log.debug("RetrievalListener added");
          // Das eigentliche Hinzufuegen des neuen Layers
          layers.add(layer);
-         log.debug("layer added");
          fireTreeStructureChanged(this, new Object[]{root}, null, null);
      }
  
--- 209,217 ----
          if (layer instanceof MapService) {
              fireMapServiceAdded(((MapService) layer));
          }
! 
          // Das eigentliche Hinzufuegen des neuen Layers
          layers.add(layer);
          fireTreeStructureChanged(this, new Object[]{root}, null, null);
      }
  
***************
*** 645,651 ****
          int counter = 0;
          while (it.hasNext()) {
              Object service = getMapServices().get(it.next());
!             if (service instanceof WMSServiceLayer) {
                  Element layerConf = ((WMSServiceLayer) service).getElement();
                  allLayerConf.addContent(layerConf);
                  counter++;
--- 646,653 ----
          int counter = 0;
          while (it.hasNext()) {
              Object service = getMapServices().get(it.next());
!             if (service instanceof SimpleFeatureSupportingRasterLayer) {
!             } else if (service instanceof WMSServiceLayer) {
                  Element layerConf = ((WMSServiceLayer) service).getElement();
                  allLayerConf.addContent(layerConf);
                  counter++;
***************
*** 687,693 ****
          try {
              final Element conf = e.getChild("cismapActiveLayerConfiguration");
              final Vector<String> links = LayerWidget.getCapabilities(conf, new Vector<String>());
-             log.debug("Capabilties links: " + links);
              //Laden der Capabilities vom Server und Speichern in einer HashMap<String url,Capabilities>;
              final HashMap<String, WMSCapabilities> capabilities = new HashMap<String, WMSCapabilities>();
  
--- 689,694 ----
***************
*** 713,731 ****
                          public void run() {
                              URL getCapURL = null;
                              try {
! //                                InputStreamReader reader = null;
                                  getCapURL = new URL(link);
!                                 URL finalPostUrl = new URL(link.substring(0, link.indexOf('?')));                                
! //                                OGCWMSCapabilitiesFactory capFact = new OGCWMSCapabilitiesFactory();
                                  CismapBroker broker = CismapBroker.getInstance();
! //                                try {
! //                                    log.debug("Layer Widget: Creating WMScapabilities for URL: " + getCapURL.toString());
! //                                    reader = HttpAuthentication.getInputStreamReaderFromURL(CismapBroker.getInstance().getMappingComponent(), getCapURL);
! //                                } catch (AuthenticationCanceledException ex) {
! //                                    log.warn(ex);
! //                                    String title = CismapBroker.getInstance().getProperty(getCapURL.toString());
! //
! //                                    if (title != null) {
  //                                        JXErrorDialog.showDialog(CismapBroker.getInstance().getMappingComponent(),
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Title"),
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text1") +
--- 714,741 ----
                          public void run() {
                              URL getCapURL = null;
                              try {
!                                 InputStreamReader reader = null;
                                  getCapURL = new URL(link);
!                                 OGCWMSCapabilitiesFactory capFact = new OGCWMSCapabilitiesFactory();
                                  CismapBroker broker = CismapBroker.getInstance();
!                                 try {
!                                     log.debug("Layer Widget: Creating WMScapabilities for URL: " + getCapURL.toString());
!                                     reader = HttpAuthentication.getInputStreamReaderFromURL(CismapBroker.getInstance().getMappingComponent(), getCapURL);
!                                 } catch (AuthenticationCanceledException ex) {
!                                     log.warn(ex);
!                                     String title = CismapBroker.getInstance().getProperty(getCapURL.toString());
! 
!                                     if (title != null) {
! //                                        ErrorInfo ei = new ErrorInfo("title", "basicErrorMessage", "detailedErrorMessage", "category", tt, Level.ALL, null);
! //                                        JXErrorPane.showDialog(PrintingWidget.this, ei);
!                                         ErrorInfo ei = new ErrorInfo(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Title"), java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text1") +
!                                                 "\"" +
!                                                 title +
!                                                 "\" " +
!                                                 java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text2"), null, null, ex, Level.ALL, null);
!                                         JXErrorPane.showDialog(CismapBroker.getInstance().getMappingComponent(), ei);
! 
! 
  //                                        JXErrorDialog.showDialog(CismapBroker.getInstance().getMappingComponent(),
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Title"),
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text1") +
***************
*** 733,768 ****
  //                                                title +
  //                                                "\" " +
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text2"));
! //                                    } else {
! //                                        title = getCapURL.toString();
! //                                        if (title.startsWith("http://") && title.length() > 21) {
! //                                            title = title.substring(7, 21) + "...";
! //                                        } else if (title.length() > 14) {
! //                                            title = title.substring(0, 14) + "...";
! //                                        }
  //                                        JXErrorDialog.showDialog(CismapBroker.getInstance().getMappingComponent(),
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Title"),
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text1") +
  //                                                "\"" + title + "\" " +
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text2"));
! //                                    }
! //                                }
!                                 //ToDo Probleme mit WFS wird aber denke ich nicht gebraucht
!                                 log.debug("rufe WMSCapabilities für " + finalPostUrl + " ab");
!                                 OGCWMSCapabilitiesFactory capFact = new OGCWMSCapabilitiesFactory();
!                                 InputStream result = WebAccessManager.getInstance().doRequest(new URL(link));
!                                 //ToDO Langsam                                
!                                 WMSCapabilities cap = capFact.createCapabilities(new BufferedReader(new InputStreamReader(result)));
! //ToDo funktionalität abgeschaltet steckt zur zeit in CismetGUICommons --> refactoring
! //                                broker.addHttpCredentialProviderCapabilities(cap, broker.getHttpCredentialProviderURL(getCapURL));
! //                                if (broker.isServerSecuredByPassword(cap)) {
! //                                    broker.addProperty(getCapURL.toString(), cap.getCapability().getLayer().getTitle());
! //                                }
                                  capabilities.put(link, cap);
                              } catch (Exception ex) {
-                                 log.debug("Exception für URL: " + link,ex);
                                  log.warn(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.RetrievingCapabilitiesExceptions") + ":", ex);
                              }
                              try {
                                  barrier.await();
                              } catch (InterruptedException ex) {
--- 743,778 ----
  //                                                title +
  //                                                "\" " +
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text2"));
!                                     } else {
!                                         title = getCapURL.toString();
!                                         if (title.startsWith("http://") && title.length() > 21) {
!                                             title = title.substring(7, 21) + "...";
!                                         } else if (title.length() > 14) {
!                                             title = title.substring(0, 14) + "...";
!                                         }
!                                         ErrorInfo ei = new ErrorInfo(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Title"), java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text1") +
!                                                 "\"" + title + "\" " +
!                                                 java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text2"), null, null, ex, Level.ALL, null);
!                                         JXErrorPane.showDialog(CismapBroker.getInstance().getMappingComponent(), ei);
! 
  //                                        JXErrorDialog.showDialog(CismapBroker.getInstance().getMappingComponent(),
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Title"),
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text1") +
  //                                                "\"" + title + "\" " +
  //                                                java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.AuthenticationCanceled.Text2"));
!                                     }
!                                 }
!                                 WMSCapabilities cap = capFact.createCapabilities(reader);
!                                 broker.addHttpCredentialProviderCapabilities(cap, broker.getHttpCredentialProviderURL(getCapURL));
!                                 if (HttpAuthentication.isServerSecuredByPassword(cap)) {
!                                     broker.addProperty(getCapURL.toString(), cap.getCapability().getLayer().getTitle());
!                                 }
! 
                                  capabilities.put(link, cap);
                              } catch (Exception ex) {
                                  log.warn(java.util.ResourceBundle.getBundle("de/cismet/cismap/commons/GuiBundle").getString("LayerWidget.RetrievingCapabilitiesExceptions") + ":", ex);
                              }
+ 
                              try {
                                  barrier.await();
                              } catch (InterruptedException ex) {
Index: de/cismet/cismap/commons/gui/layerwidget/ActiveLayerTableCellEditor.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/layerwidget/ActiveLayerTableCellEditor.java,v
retrieving revision 1.23
retrieving revision 1.24
diff -c -r1.23 -r1.24
*** de/cismet/cismap/commons/gui/layerwidget/ActiveLayerTableCellEditor.java	16 Jun 2008 09:28:23 -0000	1.23
--- de/cismet/cismap/commons/gui/layerwidget/ActiveLayerTableCellEditor.java	2 Dec 2008 16:18:14 -0000	1.24
***************
*** 50,55 ****
--- 50,56 ----
  import java.awt.BorderLayout;
  import java.awt.Color;
  import java.awt.Component;
+ import java.awt.EventQueue;
  import java.awt.Graphics;
  import java.awt.Graphics2D;
  import java.awt.event.ActionEvent;
***************
*** 132,140 ****
          //progress.setUI(new MetalProgressBarUI());
          progress.setString("");
          progress.setStringPainted(true);
!         
          visibilityLabel.setOpaque(false);
          visibilityLabel.addMouseListener(new MouseListener() {
              @Override
              public void mouseClicked(MouseEvent e) {
                  if (e.getClickCount() == 2) {
--- 133,142 ----
          //progress.setUI(new MetalProgressBarUI());
          progress.setString("");
          progress.setStringPainted(true);
! 
          visibilityLabel.setOpaque(false);
          visibilityLabel.addMouseListener(new MouseListener() {
+ 
              @Override
              public void mouseClicked(MouseEvent e) {
                  if (e.getClickCount() == 2) {
***************
*** 156,174 ****
                      }
                  }
              }
!             public void mousePressed(MouseEvent e) {}
!             public void mouseReleased(MouseEvent e) {}
!             public void mouseEntered(MouseEvent e) {}
!             public void mouseExited(MouseEvent e) {}
          });
!         
          informationBox = new JCheckBox();
          informationBox.setHorizontalAlignment(JCheckBox.CENTER);
          cbbStyleChooser = new JComboBox();
          cbbStyleChooser.setEditable(false);
          cbbStyleChooser.setRenderer(new StyleChooserCellRenderer());
!         
          informationBox.addActionListener(new ActionListener() {
              @Override
              public void actionPerformed(ActionEvent e) {
                  WMSLayer l = null;
--- 158,185 ----
                      }
                  }
              }
! 
!             public void mousePressed(MouseEvent e) {
!             }
! 
!             public void mouseReleased(MouseEvent e) {
!             }
! 
!             public void mouseEntered(MouseEvent e) {
!             }
! 
!             public void mouseExited(MouseEvent e) {
!             }
          });
! 
          informationBox = new JCheckBox();
          informationBox.setHorizontalAlignment(JCheckBox.CENTER);
          cbbStyleChooser = new JComboBox();
          cbbStyleChooser.setEditable(false);
          cbbStyleChooser.setRenderer(new StyleChooserCellRenderer());
! 
          informationBox.addActionListener(new ActionListener() {
+ 
              @Override
              public void actionPerformed(ActionEvent e) {
                  WMSLayer l = null;
***************
*** 183,212 ****
                  CismapBroker.getInstance().fireLayerInformationStatusChanged(ale);
              }
          });
!         
          cbbStyleChooser.addActionListener(new ActionListener() {
              public void actionPerformed(ActionEvent e) {
                  WMSLayer l = null;
                  if (value instanceof WMSLayer) {
                      l = ((WMSLayer) value);
                  } else if (value instanceof WMSServiceLayer && ((WMSServiceLayer) value).getWMSLayers().size() == 1) {
                      l = ((WMSLayer) ((WMSServiceLayer) value).getWMSLayers().get(0));
                  }
!                 l.setSelectedStyle((Style) cbbStyleChooser.getSelectedItem());
!                 ActiveLayerEvent ale = new ActiveLayerEvent();
!                 ale.setLayer(l.getParentServiceLayer());
!                ((de.cismet.cismap.commons.retrieval.RetrievalService)value).retrieve(true);
!                 // ((RetrievalService)value).retrieve();
!                 CismapBroker.getInstance().fireLayerRemoved(ale);
!                 CismapBroker.getInstance().fireLayerAdded(ale);
! 
! 
              }
          });
  
          moreButton.setFocusPainted(false);
          moreButton.setEnabled(false);
          moreButton.addActionListener(new ActionListener() {
              @Override
              public void actionPerformed(ActionEvent e) {
                  //System.out.println("MORE"+value);
--- 194,225 ----
                  CismapBroker.getInstance().fireLayerInformationStatusChanged(ale);
              }
          });
! 
          cbbStyleChooser.addActionListener(new ActionListener() {
+ 
              public void actionPerformed(ActionEvent e) {
+ 
                  WMSLayer l = null;
                  if (value instanceof WMSLayer) {
                      l = ((WMSLayer) value);
                  } else if (value instanceof WMSServiceLayer && ((WMSServiceLayer) value).getWMSLayers().size() == 1) {
                      l = ((WMSLayer) ((WMSServiceLayer) value).getWMSLayers().get(0));
                  }
!                 if (!(l.getSelectedStyle().equals((Style) cbbStyleChooser.getSelectedItem()))) {
!                     ActiveLayerEvent ale = new ActiveLayerEvent();
!                     ale.setLayer(l.getParentServiceLayer());
!                     CismapBroker.getInstance().fireLayerRemoved(ale);
!                     l.setSelectedStyle((Style) cbbStyleChooser.getSelectedItem());
!                     ((de.cismet.cismap.commons.retrieval.RetrievalService) value).retrieve(true);
!                     CismapBroker.getInstance().fireLayerAdded(ale);
!                 }
              }
          });
  
          moreButton.setFocusPainted(false);
          moreButton.setEnabled(false);
          moreButton.addActionListener(new ActionListener() {
+ 
              @Override
              public void actionPerformed(ActionEvent e) {
                  //System.out.println("MORE"+value);
***************
*** 226,235 ****
--- 239,250 ----
          wfsStyleButton.setContentAreaFilled(false);
          wfsStyleButton.setIconTextGap(0);
          wfsStyleButton.addMouseListener(new MouseListener() {
+ 
              @Override
              public void mouseClicked(MouseEvent e) {
                  if (e.getClickCount() == 2) {
                      Thread t = new Thread(new Runnable() {
+ 
                          @Override
                          public void run() {
                              WebFeatureService tempWFS = (WebFeatureService) value;
***************
*** 276,285 ****
                  }
              }
  
!             public void mousePressed(MouseEvent e) {}
!             public void mouseReleased(MouseEvent e) {}
!             public void mouseEntered(MouseEvent e) {}
!             public void mouseExited(MouseEvent e) {}
          });
          informationCellEditor = new DefaultCellEditor(informationBox);
          stylesCellEditor = new DefaultCellEditor(cbbStyleChooser);
--- 291,307 ----
                  }
              }
  
!             public void mousePressed(MouseEvent e) {
!             }
! 
!             public void mouseReleased(MouseEvent e) {
!             }
! 
!             public void mouseEntered(MouseEvent e) {
!             }
! 
!             public void mouseExited(MouseEvent e) {
!             }
          });
          informationCellEditor = new DefaultCellEditor(informationBox);
          stylesCellEditor = new DefaultCellEditor(cbbStyleChooser);
***************
*** 288,293 ****
--- 310,316 ----
          progress.add(slider, BorderLayout.CENTER);
          slider.setOpaque(false);
          slider.addChangeListener(new ChangeListener() {
+ 
              @Override
              public void stateChanged(ChangeEvent e) {
                  JSlider slider = (JSlider) e.getSource();
***************
*** 308,317 ****
              }
          });
          slider.addMouseListener(new MouseListener() {
!             public void mouseReleased(MouseEvent e) {}
!             public void mousePressed(MouseEvent e) {}
!             public void mouseExited(MouseEvent e) {}
!             public void mouseEntered(MouseEvent e) {}
              public void mouseClicked(MouseEvent e) {
                  log.debug("Click" + e);
              }
--- 331,349 ----
              }
          });
          slider.addMouseListener(new MouseListener() {
! 
!             public void mouseReleased(MouseEvent e) {
!             }
! 
!             public void mousePressed(MouseEvent e) {
!             }
! 
!             public void mouseExited(MouseEvent e) {
!             }
! 
!             public void mouseEntered(MouseEvent e) {
!             }
! 
              public void mouseClicked(MouseEvent e) {
                  log.debug("Click" + e);
              }
***************
*** 387,396 ****
          }
          if (realColumn == 0) {
              TableCellRenderer renderer = table.getCellRenderer(row, column);
!             visibilityLabel.setIcon(((JLabel)renderer.getTableCellRendererComponent(table, value, isSelected, isSelected, row, column)).getIcon());
              return visibilityLabel;
          } else if (realColumn == 2) {
!             log.debug("Editor Spalte="+realColumn);
              if (value instanceof WMSServiceLayer) {
                  log.debug("Combo");
                  DefaultComboBoxModel model = new DefaultComboBoxModel(wmsLayer.getOgcCapabilitiesLayer().getStyles());
--- 419,428 ----
          }
          if (realColumn == 0) {
              TableCellRenderer renderer = table.getCellRenderer(row, column);
!             visibilityLabel.setIcon(((JLabel) renderer.getTableCellRendererComponent(table, value, isSelected, isSelected, row, column)).getIcon());
              return visibilityLabel;
          } else if (realColumn == 2) {
!             log.debug("Editor Spalte=" + realColumn);
              if (value instanceof WMSServiceLayer) {
                  log.debug("Combo");
                  DefaultComboBoxModel model = new DefaultComboBoxModel(wmsLayer.getOgcCapabilitiesLayer().getStyles());
Index: de/cismet/cismap/commons/gui/layerwidget/LayerWidget.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/layerwidget/LayerWidget.java,v
retrieving revision 1.39.6.1
retrieving revision 1.39
diff -c -r1.39.6.1 -r1.39
*** de/cismet/cismap/commons/gui/layerwidget/LayerWidget.java	1 Oct 2008 09:30:58 -0000	1.39.6.1
--- de/cismet/cismap/commons/gui/layerwidget/LayerWidget.java	28 May 2008 07:51:50 -0000	1.39
***************
*** 456,471 ****
              final Vector v = new Vector();
              dtde.dropComplete(true);
              if (o instanceof SelectionAndCapabilities) {
-                 log.debug("instance of SelectionAndCapabilities");
                  TreePath[] tpa = ((SelectionAndCapabilities) o).getSelection();
-                 log.debug("Treepath size: "+tpa.length);
                  for (int i = 0; i < tpa.length; ++i) {
-                     log.debug("Treepath added: "+tpa[i]);
                      v.add(tpa[i]);
                  }
                  WMSServiceLayer l = new WMSServiceLayer(v);
                  if (l.getWMSLayers().size() > 0) {
-                     log.debug("mehr als 0 WMS Layer selektiert");
                      if (treeTable.getEditingRow() != -1 && treeTable.getEditingColumn() != -1) {
                          treeTable.getCellEditor(treeTable.getEditingRow(), treeTable.getEditingColumn()).stopCellEditing();
                      }
--- 456,467 ----
Index: de/cismet/cismap/commons/gui/piccolo/PFeature.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/piccolo/PFeature.java,v
retrieving revision 1.75
retrieving revision 1.77
diff -c -r1.75 -r1.77
*** de/cismet/cismap/commons/gui/piccolo/PFeature.java	25 Aug 2008 10:03:17 -0000	1.75
--- de/cismet/cismap/commons/gui/piccolo/PFeature.java	8 Oct 2008 14:53:52 -0000	1.77
***************
*** 76,83 ****
  import pswing.PSwingCanvas;
  
  /**
!  *
!  * @author hell
   */
  public class PFeature extends PPath implements Highlightable, Selectable, Refreshable {
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
--- 76,83 ----
  import pswing.PSwingCanvas;
  
  /**
!  * 
!  * @author hell 
   */
  public class PFeature extends PPath implements Highlightable, Selectable, Refreshable {
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
***************
*** 120,125 ****
--- 120,126 ----
      private PSwing pswingComp;
      private PText primaryAnnotation = null;
      private FeatureAnnotationSymbol pi = null;
+     
  
      /**
       * Creates a new instance of PFeature
***************
*** 131,136 ****
--- 132,138 ----
       */
      public PFeature(Feature feature, WorldToScreenTransform wtst, double x_offset, double y_offset, MappingComponent viewer) {
          this(feature, wtst, x_offset, y_offset, viewer, false);
+         
      }
  
      public PFeature(Feature feature, WorldToScreenTransform wtst, double x_offset, double y_offset, MappingComponent viewer, boolean ignoreStickyfeature) {
***************
*** 275,280 ****
--- 277,283 ----
       * @param geom vorhandenes Geometry-Objekt
       */
      private void doGeometry(Geometry geom) {
+        getPathReference().reset();
          if (viewer.isFeatureDebugging()) {
              log.debug("Enter doGeometry()");
          }
***************
*** 310,322 ****
              if (viewer.isFeatureDebugging()) {
                  log.debug("MultiLineString");
              }
!             MultiLineString mls=(MultiLineString)geom;
!             for (int i=0;i<mls.getNumGeometries();++i) {
!                 LineString ls=(LineString)mls.getGeometryN(i);
!                 coordArr=ls.getCoordinates();
                  addLinearRing(coordArr);
              }
!             
          }
          xp = new float[coordArr.length];
          yp = new float[coordArr.length];
--- 313,325 ----
              if (viewer.isFeatureDebugging()) {
                  log.debug("MultiLineString");
              }
!             MultiLineString mls = (MultiLineString) geom;
!             for (int i = 0; i < mls.getNumGeometries(); ++i) {
!                 LineString ls = (LineString) mls.getGeometryN(i);
!                 coordArr = ls.getCoordinates();
                  addLinearRing(coordArr);
              }
! 
          }
          xp = new float[coordArr.length];
          yp = new float[coordArr.length];
***************
*** 330,343 ****
          if (geom instanceof Point || geom instanceof LineString) {
              setPathToPolyline(xp, yp);
          }
!         
          refreshDesign();
      }
  
      private void doPolygon(Polygon p) {
          coordArr = p.getCoordinates();
          Coordinate[] ext = p.getExteriorRing().getCoordinates();
!         getPathReference().reset();
          addLinearRing(ext);
          getPathReference().setWindingRule(GeneralPath.WIND_EVEN_ODD);
          for (int i = 0; i < p.getNumInteriorRing(); ++i) {
--- 333,346 ----
          if (geom instanceof Point || geom instanceof LineString) {
              setPathToPolyline(xp, yp);
          }
! 
          refreshDesign();
      }
  
      private void doPolygon(Polygon p) {
          coordArr = p.getCoordinates();
          Coordinate[] ext = p.getExteriorRing().getCoordinates();
!         
          addLinearRing(ext);
          getPathReference().setWindingRule(GeneralPath.WIND_EVEN_ODD);
          for (int i = 0; i < p.getNumInteriorRing(); ++i) {
***************
*** 345,351 ****
              addLinearRing(hole);
          }
      }
-     
  //    private void doLineString(LineString ls)  {
  //        Coordinate[] coords=ls.getCoordinates();
  //        Coordinate[] points = transformCoordinateArr(coords);
--- 348,353 ----
***************
*** 353,359 ****
  //        gp.reset();
  //        gp.moveTo((float) points[0].x, (float) points[0].y);
  //    }
- 
      /**
       * F\u00FCgt dem PFeature ein weiteres Coordinate-Array hinzu. Dadurch entstehen
       * Multipolygone und Polygone mit L\u00F6chern, je nachdem, ob der neue LinearRing
--- 355,360 ----
***************
*** 388,397 ****
--- 389,400 ----
                  points[i].y = (float) (wtst.getDestY(coordinateArr[i].y) + y_offset);
              }
          }
+         
          return points;
      }
  
      /**
+      * 
       * Setzt die Zeichenobjekte des Features (z.B. unselektiert=rot) und
       * st\u00F6\u00DFt ein Neuzeichnen an.
       */
***************
*** 408,428 ****
              setPaint(null);
          } else {
              //hier muss die Anpassung bei den WFS Features hin.
!             if (getFeature() instanceof StyledFeature) {
                  StyledFeature sf = (StyledFeature) getFeature();
                  if (sf.getLineWidth() <= 1) {
                      setStroke(new FixedWidthStroke());
                  } else {
!                     OldFixedWidthStroke old = new OldFixedWidthStroke();
!                     old.setMultiplyer(sf.getLineWidth());
                      setStroke(old);
                  }
                  // Falls absichtlich keine Linie gesetzt worden ist (z.B. im StyleDialog)
!                 if (sf.getLinePaint() == null) setStroke(null);
              }
  
!             if (getFeature().getGeometry() instanceof LineString||getFeature().getGeometry() instanceof MultiLineString ) {
!                 //setPaint(null);
              } else {
                  if ((feature instanceof StyledFeature)) {
                      java.awt.Paint paint = ((StyledFeature) feature).getFillingPaint();
--- 411,447 ----
              setPaint(null);
          } else {
              //hier muss die Anpassung bei den WFS Features hin.
!             Stroke overridingstroke = null;
!             if (getFeature() instanceof XStyledFeature) {
!                 XStyledFeature xsf = (XStyledFeature) getFeature();
!                 overridingstroke = xsf.getLineStyle();
!             }
! 
!             if (getFeature() instanceof StyledFeature && overridingstroke == null) {
                  StyledFeature sf = (StyledFeature) getFeature();
                  if (sf.getLineWidth() <= 1) {
                      setStroke(new FixedWidthStroke());
                  } else {
!                     CustomFixedWidthStroke old = new CustomFixedWidthStroke(sf.getLineWidth());
                      setStroke(old);
                  }
                  // Falls absichtlich keine Linie gesetzt worden ist (z.B. im StyleDialog)
!                 if (sf.getLinePaint() == null) {
!                     setStroke(null);
!                 }
              }
  
!             if (overridingstroke != null) {
!                 setStroke(overridingstroke);
!             }
!             if (getFeature().getGeometry() instanceof LineString || getFeature().getGeometry() instanceof MultiLineString) {
!                 if ((feature instanceof StyledFeature)) {
!                     java.awt.Paint linePaint = ((StyledFeature) feature).getLinePaint();
!                     if (linePaint != null) {
!                         setStrokePaint(linePaint);
!                     }
! 
!                 }
              } else {
                  if ((feature instanceof StyledFeature)) {
                      java.awt.Paint paint = ((StyledFeature) feature).getFillingPaint();
***************
*** 436,443 ****
                      }
                  }
              }
              setSelected(this.isSelected());
!             
              //TODO:Wenn feature=labeledFeature jetzt noch Anpassungen machen
              if ((feature instanceof AnnotatedFeature && ((AnnotatedFeature) feature).isPrimaryAnnotationVisible() && ((AnnotatedFeature) feature).getPrimaryAnnotation() != null)) {
                  final AnnotatedFeature af = (AnnotatedFeature) feature;
--- 455,464 ----
                      }
                  }
              }
+             stroke = getStroke();
+             strokePaint = getStrokePaint();
              setSelected(this.isSelected());
! 
              //TODO:Wenn feature=labeledFeature jetzt noch Anpassungen machen
              if ((feature instanceof AnnotatedFeature && ((AnnotatedFeature) feature).isPrimaryAnnotationVisible() && ((AnnotatedFeature) feature).getPrimaryAnnotation() != null)) {
                  final AnnotatedFeature af = (AnnotatedFeature) feature;
***************
*** 469,475 ****
                  boolean vis = primaryAnnotation.getVisible();
  
                  Point intPoint = getFeature().getGeometry().getInteriorPoint();
!                 
                  primaryAnnotation.setOffset(wtst.getScreenX(intPoint.getX()), wtst.getScreenY(intPoint.getY()));
  
                  addChild(primaryAnnotation);
--- 490,496 ----
                  boolean vis = primaryAnnotation.getVisible();
  
                  Point intPoint = getFeature().getGeometry().getInteriorPoint();
! 
                  primaryAnnotation.setOffset(wtst.getScreenX(intPoint.getX()), wtst.getScreenY(intPoint.getY()));
  
                  addChild(primaryAnnotation);
***************
*** 492,498 ****
              ptext.setVisible(false);
          }
      }
!     
      /**
       * Entfernt eine Koordinate aus der Geometrie, z.B. beim L\u00F6schen eines Handles.
       * @param position Position des zu l\u00F6schenden Punkes im Koordinatenarray
--- 513,519 ----
              ptext.setVisible(false);
          }
      }
! 
      /**
       * Entfernt eine Koordinate aus der Geometrie, z.B. beim L\u00F6schen eines Handles.
       * @param position Position des zu l\u00F6schenden Punkes im Koordinatenarray
***************
*** 736,742 ****
      public Coordinate[] removeCoordinateFromOutside(int position, Coordinate[] original) {
          return removeCoordinate(position, original);
      }
!     
      /**
       * Erzeugt alle Handles f\u00FCr dieses PFeature auf dem \u00FCbergebenen HandleLayer.
       * @param handleLayer PLayer der die Handles aufnimmt
--- 757,763 ----
      public Coordinate[] removeCoordinateFromOutside(int position, Coordinate[] original) {
          return removeCoordinate(position, original);
      }
! 
      /**
       * Erzeugt alle Handles f\u00FCr dieses PFeature auf dem \u00FCbergebenen HandleLayer.
       * @param handleLayer PLayer der die Handles aufnimmt
***************
*** 820,826 ****
                      } else {
                          log.warn("Movelistener zur Abstimmung der Mauszeiger nicht gefunden.");
                      }
!                     
                      if (getViewer().getHandleInteractionMode().equals(MappingComponent.ADD_HANDLE) ||
                              getViewer().getHandleInteractionMode().equals(MappingComponent.MOVE_HANDLE)) {
                          //localToParent(aLocalDimension);
--- 841,847 ----
                      } else {
                          log.warn("Movelistener zur Abstimmung der Mauszeiger nicht gefunden.");
                      }
! 
                      if (getViewer().getHandleInteractionMode().equals(MappingComponent.ADD_HANDLE) ||
                              getViewer().getHandleInteractionMode().equals(MappingComponent.MOVE_HANDLE)) {
                          //localToParent(aLocalDimension);
***************
*** 1009,1015 ****
                      removeChild(rightInfo);
                      leftInfo = null;
                      rightInfo = null;
!                     
                      if ((getViewer().getHandleInteractionMode().equals(MappingComponent.MOVE_HANDLE)) &&
                              (Math.abs(startX - endX) > 0.001d) || (Math.abs(startY - endY) > 0.001d)) {
                          if (viewer.isFeatureDebugging()) {
--- 1030,1036 ----
                      removeChild(rightInfo);
                      leftInfo = null;
                      rightInfo = null;
! 
                      if ((getViewer().getHandleInteractionMode().equals(MappingComponent.MOVE_HANDLE)) &&
                              (Math.abs(startX - endX) > 0.001d) || (Math.abs(startY - endY) > 0.001d)) {
                          if (viewer.isFeatureDebugging()) {
***************
*** 1120,1125 ****
--- 1141,1147 ----
          };
          ///Handle End
          EventQueue.invokeLater(new Runnable() {
+ 
              public void run() {
                  handleLayer.addChild(h);
                  h.addClientProperty("coordinate", getCoordArr()[position]);
***************
*** 1170,1176 ****
          log.info("glueCoords.size() = " + glueCoords.size());
          return glueCoords;
      }
!     
      /**
       * Erzeugt alle RotaionHandles f\u00FCr dieses PFeature auf dem \u00FCbergebenen HandleLayer.
       * @param handleLayer PLayer der die RotationHandles aufnimmt
--- 1192,1198 ----
          log.info("glueCoords.size() = " + glueCoords.size());
          return glueCoords;
      }
! 
      /**
       * Erzeugt alle RotaionHandles f\u00FCr dieses PFeature auf dem \u00FCbergebenen HandleLayer.
       * @param handleLayer PLayer der die RotationHandles aufnimmt
***************
*** 1270,1276 ****
                      log.debug("startHandleDrag");
                  }
                  rotation = 0.0d;
!                 
                  // InfoNode entfernen, da sie sonst mitdreht
                  Collection selArr = getViewer().getFeatureCollection().getSelectedFeatures();
                  for (Object o : selArr) {
--- 1292,1298 ----
                      log.debug("startHandleDrag");
                  }
                  rotation = 0.0d;
! 
                  // InfoNode entfernen, da sie sonst mitdreht
                  Collection selArr = getViewer().getFeatureCollection().getSelectedFeatures();
                  for (Object o : selArr) {
***************
*** 1279,1285 ****
                          pf.getInfoNode().setVisible(false);
                      }
                  }
!                 
                  handleLayer.removeAllChildren();
                  handleLayer.addChild(this);
                  if (pivotHandle != null) {
--- 1301,1307 ----
                          pf.getInfoNode().setVisible(false);
                      }
                  }
! 
                  handleLayer.removeAllChildren();
                  handleLayer.addChild(this);
                  if (pivotHandle != null) {
***************
*** 1389,1395 ****
              }
          });
      }
!     
      /**
       * Erzeugt den Rotations-Angelpunkt. Der Benutzer kann den Punkt verschieben,
       * um die Drehung um einen anderen Punkt als den Mittel-/Schwerpunkt 
--- 1411,1417 ----
              }
          });
      }
! 
      /**
       * Erzeugt den Rotations-Angelpunkt. Der Benutzer kann den Punkt verschieben,
       * um die Drehung um einen anderen Punkt als den Mittel-/Schwerpunkt 
***************
*** 1560,1566 ****
          // create vectors
          double[] mv = {(mousePos.getX() - mid.getX()), (mousePos.getY() - mid.getY())};
          double[] hv = {(x - mid.getX()), (y - mid.getY())};
!         
          double cosm = ((mv[0]) / Math.hypot(mv[0], mv[1]));
          double cosh = ((hv[0]) / Math.hypot(hv[0], hv[1]));
          double resH = Math.acos(cosh);
--- 1582,1588 ----
          // create vectors
          double[] mv = {(mousePos.getX() - mid.getX()), (mousePos.getY() - mid.getY())};
          double[] hv = {(x - mid.getX()), (y - mid.getY())};
! 
          double cosm = ((mv[0]) / Math.hypot(mv[0], mv[1]));
          double cosh = ((hv[0]) / Math.hypot(hv[0], hv[1]));
          double resH = Math.acos(cosh);
***************
*** 2013,2021 ****
  //            return false;
  //        }
  //    }
-     
      // <editor-fold defaultstate="collapsed" desc="Setters & Getters">
-    
      public boolean isInfoNodeExpanded() {
          return infoPanel != null && infoPanel.isExpanded();
      }
--- 2035,2041 ----
***************
*** 2050,2056 ****
          PPath pp = new PPath();
          pp.setPathToPolyline(xp, yp);
          //pp.setStroke(new FixedWidthStroke());
!         pp.setStroke(new BasicStroke());
          return pp;
      }
  
--- 2070,2076 ----
          PPath pp = new PPath();
          pp.setPathToPolyline(xp, yp);
          //pp.setStroke(new FixedWidthStroke());
! //        pp.setStroke(new BasicStroke());
          return pp;
      }
  
***************
*** 2170,2187 ****
          } // LINESTRING
          else if (feature.getGeometry() instanceof LineString || feature.getGeometry() instanceof MultiLineString) {
              if (selected) {
!                 OldFixedWidthStroke fws = new OldFixedWidthStroke();
!                 fws.setMultiplyer(5f);
                  setStroke(fws);
                  setStrokePaint(javax.swing.UIManager.getDefaults().getColor("Table.selectionBackground"));
                  setPaint(null);
              } else {
!                 setStroke(new FixedWidthStroke());
! //                if (stroke!=null) {
! //                    setStroke(stroke);
! //                } else {
! //                    setStroke(new FixedWidthStroke());
! //                }
                  if (strokePaint != null) {
                      setStrokePaint(strokePaint);
                  } else {
--- 2190,2206 ----
          } // LINESTRING
          else if (feature.getGeometry() instanceof LineString || feature.getGeometry() instanceof MultiLineString) {
              if (selected) {
!                 CustomFixedWidthStroke fws = new CustomFixedWidthStroke(5f);
                  setStroke(fws);
                  setStrokePaint(javax.swing.UIManager.getDefaults().getColor("Table.selectionBackground"));
                  setPaint(null);
              } else {
!                 //setStroke(new FixedWidthStroke());
!                 if (stroke != null) {
!                     setStroke(stroke);
!                 } else {
!                     setStroke(new FixedWidthStroke());
!                 }
                  if (strokePaint != null) {
                      setStrokePaint(strokePaint);
                  } else {
***************
*** 2190,2195 ****
--- 2209,2220 ----
              }
          } // POLYGON
          else {
+             if (stroke != null) {
+                 setStroke(stroke);
+             } else {
+                 setStroke(new FixedWidthStroke());
+             }
+ 
              if (selected) {
                  nonSelectedPaint = getPaint();
                  if (nonSelectedPaint instanceof Color) {
***************
*** 2210,2215 ****
--- 2235,2245 ----
          repaint();
      }
  
+     public void setStroke(Stroke s) {
+         log.debug("setStroke: " + s, new CurrentStackTrace());
+         super.setStroke(s);
+     }
+ 
      public boolean isSelected() {
          return selected;
      }
Index: de/cismet/cismap/commons/gui/printing/PrintingWidget.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/printing/PrintingWidget.java,v
retrieving revision 1.20
diff -c -r1.20 PrintingWidget.java
*** de/cismet/cismap/commons/gui/printing/PrintingWidget.java	8 Jul 2008 15:15:40 -0000	1.20
--- de/cismet/cismap/commons/gui/printing/PrintingWidget.java	19 Mar 2009 14:56:42 -0000
***************
*** 12,18 ****
  import de.cismet.cismap.commons.retrieval.RetrievalEvent;
  import de.cismet.cismap.commons.retrieval.RetrievalListener;
  import de.cismet.cismap.commons.retrieval.RetrievalService;
- import de.cismet.debugged.JXErrorDialog;
  import de.cismet.tools.gui.Static2DTools;
  import de.cismet.tools.gui.StaticSwingTools;
  import de.cismet.tools.gui.imagetooltip.ImageToolTip;
--- 12,17 ----
***************
*** 20,26 ****
  import java.awt.BorderLayout;
  import java.awt.Color;
  import java.awt.Composite;
- import java.awt.EventQueue;
  import java.awt.Graphics2D;
  import java.awt.Image;
  import java.awt.image.BufferedImage;
--- 19,24 ----
***************
*** 29,34 ****
--- 27,33 ----
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.util.TreeMap;
+ import java.util.logging.Level;
  import javax.swing.ImageIcon;
  import javax.swing.JFrame;
  import javax.swing.JLabel;
***************
*** 44,49 ****
--- 43,50 ----
  import net.sf.jasperreports.engine.JasperReport;
  import net.sf.jasperreports.engine.util.JRLoader;
  import net.sf.jasperreports.view.JRViewer;
+ import org.jdesktop.swingx.JXErrorPane;
+ import org.jdesktop.swingx.error.ErrorInfo;
  
  /**
   *
***************
*** 486,492 ****
                      }
                  } catch (Throwable tt) {
                      log.error("Fehler beim Jaspern", tt);
!                     JXErrorDialog.showDialog(PrintingWidget.this, "Fehler beim Drucken", "Beim Erzeugen des Ausdruckes ist ein Fehler aufgetreten.\nStellen Sie sicher das das PDF aus dem letzen Druckvorgang\ngeschlossen oder unter anderem Namen abgespeichert\nwurde.", tt);
                      if (pdfWait.isVisible()) {
                          pdfWait.dispose();
                      }
--- 487,497 ----
                      }
                  } catch (Throwable tt) {
                      log.error("Fehler beim Jaspern", tt);
! 
!                     ErrorInfo ei = new ErrorInfo("Fehler beim Drucken", "Beim Erzeugen des Ausdruckes ist ein Fehler aufgetreten.\nStellen Sie sicher das das PDF aus dem letzen Druckvorgang\ngeschlossen oder unter anderem Namen abgespeichert\nwurde.", null,null, tt, Level.ALL, null);
!                     JXErrorPane.showDialog(PrintingWidget.this, ei);
! //                    JXErrorDialog.showDialog(, "Fehler beim Drucken", "Beim Erzeugen des Ausdruckes ist ein Fehler aufgetreten.\nStellen Sie sicher das das PDF aus dem letzen Druckvorgang\ngeschlossen oder unter anderem Namen abgespeichert\nwurde.", tt);
!                     
                      if (pdfWait.isVisible()) {
                          pdfWait.dispose();
                      }
Index: de/cismet/cismap/commons/gui/simplelayerwidget/NewSimpleInternalLayerWidget.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/gui/simplelayerwidget/NewSimpleInternalLayerWidget.java,v
retrieving revision 1.13
diff -c -r1.13 NewSimpleInternalLayerWidget.java
*** de/cismet/cismap/commons/gui/simplelayerwidget/NewSimpleInternalLayerWidget.java	2 Jun 2008 10:09:04 -0000	1.13
--- de/cismet/cismap/commons/gui/simplelayerwidget/NewSimpleInternalLayerWidget.java	19 Mar 2009 14:56:42 -0000
***************
*** 93,98 ****
--- 93,99 ----
   * @author nh
   */
  public class NewSimpleInternalLayerWidget extends JInternalFrame implements MappingModelListener, TableModelListener, DropTargetListener, Configurable {
+ 
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
      private final ImageIcon UP = new ImageIcon(getClass().getResource("/de/cismet/cismap/commons/gui/layerwidget/res/up.png"));
      private final ImageIcon DOWN = new ImageIcon(getClass().getResource("/de/cismet/cismap/commons/gui/layerwidget/res/down.png"));
***************
*** 121,133 ****
      public NewSimpleInternalLayerWidget(MappingComponent mc, boolean deactivatePopupMenuButtons) {
          log.info("SimpleInternalLayerWidget erstellen");
          this.deactivatePopupMenuButtons = deactivatePopupMenuButtons;
!         
          // JInternalFrame fixieren, indem alle MouseMotionListener der Statusbar entfernt werden
!         BasicInternalFrameUI fui = (BasicInternalFrameUI) getUI();
!         Component north = fui.getNorthPane();
!         MouseMotionListener[] listener = (MouseMotionListener[]) north.getListeners(MouseMotionListener.class);
!         for (int i = 0; i < listener.length; i++) {
!             north.removeMouseMotionListener(listener[i]);
          }
          initComponents();
          this.mc = mc;
--- 122,138 ----
      public NewSimpleInternalLayerWidget(MappingComponent mc, boolean deactivatePopupMenuButtons) {
          log.info("SimpleInternalLayerWidget erstellen");
          this.deactivatePopupMenuButtons = deactivatePopupMenuButtons;
! 
          // JInternalFrame fixieren, indem alle MouseMotionListener der Statusbar entfernt werden
!         try {
!             BasicInternalFrameUI fui = (BasicInternalFrameUI) getUI();
!             Component north = fui.getNorthPane();
!             MouseMotionListener[] listener = (MouseMotionListener[]) north.getListeners(MouseMotionListener.class);
!             for (int i = 0; i < listener.length; i++) {
!                 north.removeMouseMotionListener(listener[i]);
!             }
!         } catch (Exception e) {
!             log.error("Fehler beim Entfernen von Mousemotionlisteners", e);
          }
          initComponents();
          this.mc = mc;
***************
*** 137,148 ****
--- 142,155 ----
          up.setText("nach oben");
          up.setIcon(UP);
          up.addActionListener(new ActionListener() {
+ 
              public void actionPerformed(ActionEvent e) {
                  final TreePath tp = treeTable.getTree().getSelectionPath();
                  if (tp != null) {
                      activeLayerModel.moveLayerUp(tp);
                  }
                  EventQueue.invokeLater(new Runnable() {
+ 
                      public void run() {
                          treeTable.getTree().setSelectionPath(tp);
                          StaticSwingTools.jTableScrollToVisible(treeTable, treeTable.getSelectedRow(), 0);
***************
*** 154,165 ****
--- 161,174 ----
          down.setText("nach unten");
          down.setIcon(DOWN);
          down.addActionListener(new ActionListener() {
+ 
              public void actionPerformed(ActionEvent e) {
                  final TreePath tp = treeTable.getTree().getSelectionPath();
                  if (tp != null) {
                      activeLayerModel.moveLayerDown(tp);
                  }
                  EventQueue.invokeLater(new Runnable() {
+ 
                      public void run() {
                          treeTable.getTree().setSelectionPath(tp);
                          StaticSwingTools.jTableScrollToVisible(treeTable, treeTable.getSelectedRow(), 0);
***************
*** 171,182 ****
--- 180,193 ----
          dis.setText("deaktivieren");
          dis.setIcon(DISABLE);
          dis.addActionListener(new ActionListener() {
+ 
              public void actionPerformed(ActionEvent e) {
                  final TreePath tp = treeTable.getTree().getSelectionPath();
                  if (tp != null) {
                      activeLayerModel.disableLayer(tp);
                  }
                  EventQueue.invokeLater(new Runnable() {
+ 
                      public void run() {
                          treeTable.getTree().setSelectionPath(tp);
                      }
***************
*** 187,192 ****
--- 198,204 ----
          del.setText("entfernen");
          del.setIcon(DELETE);
          del.addActionListener(new ActionListener() {
+ 
              public void actionPerformed(ActionEvent e) {
                  TreePath tp = treeTable.getTree().getSelectionPath();
                  final int row = treeTable.getSelectedRow();
***************
*** 194,199 ****
--- 206,212 ----
                      activeLayerModel.removeLayer(tp);
                  }
                  EventQueue.invokeLater(new Runnable() {
+ 
                      public void run() {
                          treeTable.getSelectionModel().setSelectionInterval(row, row);
                      }
***************
*** 204,215 ****
--- 217,230 ----
          vis.setText("unsichtbar");
          vis.setIcon(INVISIBLE);
          vis.addActionListener(new ActionListener() {
+ 
              public void actionPerformed(ActionEvent e) {
                  final TreePath tp = treeTable.getTree().getSelectionPath();
                  if (tp != null) {
                      activeLayerModel.handleVisibility(tp);
                  }
                  EventQueue.invokeLater(new Runnable() {
+ 
                      public void run() {
                          treeTable.getTree().setSelectionPath(tp);
                      }
***************
*** 246,252 ****
              log.info("MappingModel ist kein ActiveLayerModel, kann InternalWidget nicht erstellen");
          }
      }
!     
      /**
       * Returns whether the buttons "disable" and "delete" are not shown in the
       * TreeTable popup menu.
--- 261,267 ----
              log.info("MappingModel ist kein ActiveLayerModel, kann InternalWidget nicht erstellen");
          }
      }
! 
      /**
       * Returns whether the buttons "disable" and "delete" are not shown in the
       * TreeTable popup menu.
***************
*** 255,261 ****
      public boolean isDeactivatePopupMenuButtons() {
          return this.deactivatePopupMenuButtons;
      }
!     
      /**
       * Hides or shows the buttons "disable" and "delete" in the TreeTable popup menu.
       * @param flag the new boolean value (true hides, false shows)
--- 270,276 ----
      public boolean isDeactivatePopupMenuButtons() {
          return this.deactivatePopupMenuButtons;
      }
! 
      /**
       * Hides or shows the buttons "disable" and "delete" in the TreeTable popup menu.
       * @param flag the new boolean value (true hides, false shows)
***************
*** 280,285 ****
--- 295,301 ----
      private void createTree() {
          try {
              treeTable = new JTreeTable(activeLayerModel) {
+ 
                  @Override
                  public JToolTip createToolTip() {
                      log.debug("Tooltip");
***************
*** 315,320 ****
--- 331,337 ----
              treeTable.getColumnModel().getColumn(2).setCellRenderer(tableCellRenderer);
              treeTable.setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);
              treeTable.getTree().getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {
+ 
                  public void valueChanged(TreeSelectionEvent e) {
                      if (treeTable.getTree().getSelectionPath() != null) {
                          log.debug("ActiveLayerWidget: selectionChanged()\n" + e);
***************
*** 334,339 ****
--- 351,357 ----
              treeTable.setGridColor(this.getBackground());
  
              treeTable.addMouseListener(new MouseListener() {
+ 
                  public void mouseReleased(MouseEvent e) {
                      if (e.isPopupTrigger()) {
                          popupMenu.show(e.getComponent(), e.getX(), e.getY());
***************
*** 346,367 ****
                      }
                  }
  
!                 public void mouseClicked(MouseEvent e) {}
!                 public void mouseEntered(MouseEvent e) {}
!                 public void mouseExited(MouseEvent e) {}
              });
!             
              reshapeWidget(true);
              scpMain.setViewportView(treeTable);
  
              addComponentListener(new ComponentListener() {
                  public void componentResized(ComponentEvent e) {
                      treeTable.repaint();
                  }
  
!                 public void componentMoved(ComponentEvent e) {}
!                 public void componentShown(ComponentEvent e) {}
!                 public void componentHidden(ComponentEvent e) {}
              });
          } catch (Exception ex) {
              log.error("Fehler beim erstellen der TreeTable!", ex);
--- 364,396 ----
                      }
                  }
  
!                 public void mouseClicked(MouseEvent e) {
!                 }
! 
!                 public void mouseEntered(MouseEvent e) {
!                 }
! 
!                 public void mouseExited(MouseEvent e) {
!                 }
              });
! 
              reshapeWidget(true);
              scpMain.setViewportView(treeTable);
  
              addComponentListener(new ComponentListener() {
+ 
                  public void componentResized(ComponentEvent e) {
                      treeTable.repaint();
                  }
  
!                 public void componentMoved(ComponentEvent e) {
!                 }
! 
!                 public void componentShown(ComponentEvent e) {
!                 }
! 
!                 public void componentHidden(ComponentEvent e) {
!                 }
              });
          } catch (Exception ex) {
              log.error("Fehler beim erstellen der TreeTable!", ex);
***************
*** 397,407 ****
      private javax.swing.JScrollPane scpMain;
      // End of variables declaration//GEN-END:variables
  
!     public void dragEnter(DropTargetDragEvent dtde) {}
!     public void dragOver(DropTargetDragEvent dtde) {}
!     public void dropActionChanged(DropTargetDragEvent dtde) {}
!     public void dragExit(DropTargetEvent dte) {}
!     
      public void drop(DropTargetDropEvent dtde) {
          DataFlavor TREEPATH_FLAVOR = new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType, "SelectionAndCapabilities");
          try {
--- 426,443 ----
      private javax.swing.JScrollPane scpMain;
      // End of variables declaration//GEN-END:variables
  
!     public void dragEnter(DropTargetDragEvent dtde) {
!     }
! 
!     public void dragOver(DropTargetDragEvent dtde) {
!     }
! 
!     public void dropActionChanged(DropTargetDragEvent dtde) {
!     }
! 
!     public void dragExit(DropTargetEvent dte) {
!     }
! 
      public void drop(DropTargetDropEvent dtde) {
          DataFlavor TREEPATH_FLAVOR = new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType, "SelectionAndCapabilities");
          try {
***************
*** 466,479 ****
  
      private void reshapeWidget(boolean add) {
          Dimension pref = treeTable.getPreferredSize();
!         pref.setSize(WIDGET_WIDTH, pref.height+23);
          setPreferredSize(pref);
          int posX = mc.getWidth() - getWidth() - 1;
          int posY = mc.getHeight() - getHeight() - 1;
          if (add) {
!             setBounds(posX, posY-ROW_HEIGHT, pref.width, pref.height+ROW_HEIGHT);
          } else {
!             setBounds(posX, posY+ROW_HEIGHT, pref.width, pref.height);
          }
      }
  
--- 502,515 ----
  
      private void reshapeWidget(boolean add) {
          Dimension pref = treeTable.getPreferredSize();
!         pref.setSize(WIDGET_WIDTH, pref.height + 23);
          setPreferredSize(pref);
          int posX = mc.getWidth() - getWidth() - 1;
          int posY = mc.getHeight() - getHeight() - 1;
          if (add) {
!             setBounds(posX, posY - ROW_HEIGHT, pref.width, pref.height + ROW_HEIGHT);
          } else {
!             setBounds(posX, posY + ROW_HEIGHT, pref.width, pref.height);
          }
      }
  
Index: de/cismet/cismap/commons/interaction/CismapBroker.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/interaction/CismapBroker.java,v
retrieving revision 1.16.10.2
retrieving revision 1.16
diff -c -r1.16.10.2 -r1.16
*** de/cismet/cismap/commons/interaction/CismapBroker.java	9 Oct 2008 12:08:02 -0000	1.16.10.2
--- de/cismet/cismap/commons/interaction/CismapBroker.java	7 Mar 2008 11:23:31 -0000	1.16
***************
*** 64,70 ****
  import java.util.Vector;
  import java.util.prefs.BackingStoreException;
  import java.util.prefs.Preferences;
- import org.apache.commons.httpclient.UsernamePasswordCredentials;
  import org.deegree.services.wms.capabilities.WMSCapabilities;
  
  /**
--- 64,69 ----
***************
*** 72,78 ****
   * @author thorsten.hell@cismet.de
   */
  public class CismapBroker {
- 
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
      private static final String FS = System.getProperty("file.separator");
      private static final String USER_HOME_DIRECTORY = System.getProperty("user.home");
--- 71,76 ----
***************
*** 93,99 ****
      private Vector<MapSearchListener> mapSearchListeners = new Vector<MapSearchListener>();
      private Vector<MapDnDListener> mapDnDListeners = new Vector<MapDnDListener>();
      private Vector<FeatureCollectionListener> featureCollectionListeners = new Vector<FeatureCollectionListener>();
!     private Vector<MapBoundsListener> mapBoundsListeners = new Vector<MapBoundsListener>();    
      private Hashtable<WMSCapabilities, GUICredentialsProvider> httpCredentialsForCapabilities = new Hashtable<WMSCapabilities, GUICredentialsProvider>();
      private String srs;
      private String preferredRasterFormat;
--- 91,98 ----
      private Vector<MapSearchListener> mapSearchListeners = new Vector<MapSearchListener>();
      private Vector<MapDnDListener> mapDnDListeners = new Vector<MapDnDListener>();
      private Vector<FeatureCollectionListener> featureCollectionListeners = new Vector<FeatureCollectionListener>();
!     private Vector<MapBoundsListener> mapBoundsListeners = new Vector<MapBoundsListener>();
!     private Hashtable<URL, GUICredentialsProvider> httpCredentialsForURLS = new Hashtable<URL, GUICredentialsProvider>();
      private Hashtable<WMSCapabilities, GUICredentialsProvider> httpCredentialsForCapabilities = new Hashtable<WMSCapabilities, GUICredentialsProvider>();
      private String srs;
      private String preferredRasterFormat;
***************
*** 287,292 ****
--- 286,292 ----
  //            it.next().selectionChanged(mme);
  //        }
  //    }
+     
      public void fireMapBoundsChanged() {
          for (Iterator<MapBoundsListener> it = mapBoundsListeners.iterator(); it.hasNext();) {
              it.next().shownMapBoundsChanged();
***************
*** 376,381 ****
--- 376,382 ----
      }
  
      public void selectionChanged(edu.umd.cs.piccolox.event.PNotification notification) {
+         
      }
  
  //    public LayerWidget getLayerWidget() {
***************
*** 393,402 ****
--- 394,471 ----
  //    public void setInitialBoundingBox(BoundingBox initialBoundingBox) {
  //        this.initialBoundingBox = initialBoundingBox;
  //    }
+     
      public MappingComponent getMappingComponent() {
          return mappingComponent;
      }
  
+     public GUICredentialsProvider getHttpCredentialProviderURL(URL url) {
+         return httpCredentialsForURLS.get(url);
+     }
+ 
+     public synchronized GUICredentialsProvider createSynchronizedCP(URL url, Component parent) {
+         log.debug("Credential Provider should be created synchronously");
+         GUICredentialsProvider cp = httpCredentialsForURLS.get(url);
+         if (cp != null) {
+             log.debug("Credential Provider was already available: " + url.toString());
+             return cp;
+         } else {
+             log.debug("A new Credential Provider instance was created for: " + url.toString());
+             cp = new GUICredentialsProvider(url, parent);
+             httpCredentialsForURLS.put(url, cp);
+             return cp;
+         }
+     }
+ 
+     public synchronized GUICredentialsProvider createSynchronizedCP(URL url) {
+         GUICredentialsProvider cp = httpCredentialsForURLS.get(url);
+         if (cp != null) {
+             return cp;
+         } else {
+             cp = new GUICredentialsProvider(url);
+             httpCredentialsForURLS.put(url, cp);
+             return cp;
+         }
+     }
+ 
+     public synchronized GUICredentialsProvider createSynchronizedCP(URL url, Component parent, WMSCapabilities cap) {
+         log.debug("Credential Provider should be created synchronously");
+         GUICredentialsProvider cp = httpCredentialsForCapabilities.get(cap);
+         if (cp != null) {
+             log.debug("Credential Provider was already available: " + url.toString());
+             return cp;
+         } else {
+             log.debug("A new Credential Provider instance was created for: " + url.toString());
+             cp = new GUICredentialsProvider(url, parent);
+             httpCredentialsForURLS.put(url, cp);
+             cp.setTitle(cap.getCapability().getLayer().getTitle());
+             return cp;
+         }
+     }
+ 
+     public synchronized GUICredentialsProvider createSynchronizedCP(URL url, WMSCapabilities cap) {
+         log.debug("Credential Provider should be created synchronously");
+         GUICredentialsProvider cp = httpCredentialsForCapabilities.get(cap);
+         if (cp != null) {
+             log.debug("Credential Provider was already available: " + url.toString());
+             return cp;
+         } else {
+             log.debug("A new Credential Provider instance was created for: " + url.toString());
+             cp = new GUICredentialsProvider(url);
+             httpCredentialsForURLS.put(url, cp);
+             cp.setTitle(cap.getCapability().getLayer().getTitle());
+             return cp;
+         }
+     }
+ 
+     public void addHttpCredentialProviderCapabilities(WMSCapabilities caps, GUICredentialsProvider httpCredentialsProvider) {
+         httpCredentialsForCapabilities.put(caps, httpCredentialsProvider);
+     }
+ 
+     public GUICredentialsProvider getHttpCredentialProviderCapabilities(WMSCapabilities caps) {
+         return httpCredentialsForCapabilities.get(caps);
+     }
+ 
      private void initAliases() {
          log.debug("initializing server aliases property");
          try {
***************
*** 453,459 ****
      }
  
      public void addProperty(String key, String value) {
!         userProperties.setProperty(key, value);        
          log.debug("Server alias added  key: " + key + " value: " + value);
      }
  
--- 522,528 ----
      }
  
      public void addProperty(String key, String value) {
!         userProperties.setProperty(key, value);
          log.debug("Server alias added  key: " + key + " value: " + value);
      }
  
Index: de/cismet/cismap/commons/raster/wms/AbstractWMS.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/raster/wms/AbstractWMS.java,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -r1.7 -r1.8
*** de/cismet/cismap/commons/raster/wms/AbstractWMS.java	7 Mar 2008 11:23:31 -0000	1.7
--- de/cismet/cismap/commons/raster/wms/AbstractWMS.java	14 Nov 2008 12:53:27 -0000	1.8
***************
*** 40,45 ****
--- 40,46 ----
  import de.cismet.cismap.commons.rasterservice.MapService;
  import de.cismet.cismap.commons.retrieval.AbstractRetrievalService;
  import de.cismet.cismap.commons.retrieval.RetrievalListener;
+ import de.cismet.tools.CurrentStackTrace;
  import java.awt.Image;
  
  /**
***************
*** 91,97 ****
          this.fireRetrievalProgress(e);
      }
      public void retrievalError(de.cismet.cismap.commons.retrieval.RetrievalEvent e) {
!         log.warn("retrievalError");
          this.fireRetrievalError(e);
      }
  
--- 92,98 ----
          this.fireRetrievalProgress(e);
      }
      public void retrievalError(de.cismet.cismap.commons.retrieval.RetrievalEvent e) {
!         log.warn("retrievalError",new CurrentStackTrace());
          this.fireRetrievalError(e);
      }
  
Index: de/cismet/cismap/commons/raster/wms/WMSCapabilitiesTreeModel.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/raster/wms/WMSCapabilitiesTreeModel.java,v
retrieving revision 1.2.8.1
retrieving revision 1.2
diff -c -r1.2.8.1 -r1.2
*** de/cismet/cismap/commons/raster/wms/WMSCapabilitiesTreeModel.java	1 Oct 2008 09:30:57 -0000	1.2.8.1
--- de/cismet/cismap/commons/raster/wms/WMSCapabilitiesTreeModel.java	14 Apr 2008 08:58:45 -0000	1.2
***************
*** 34,40 ****
  
  package de.cismet.cismap.commons.raster.wms;
  
- import de.cismet.cismap.commons.capabilities.AbstractCapabilitiesTreeModel;
  import java.util.Vector;
  import javax.swing.tree.TreeModel;
  import org.deegree.services.wms.capabilities.Layer;
--- 34,39 ----
***************
*** 45,51 ****
   *
   * @author thorsten.hell@cismet.de
   */
! public class WMSCapabilitiesTreeModel extends AbstractCapabilitiesTreeModel{
      private WMSCapabilities capabilities=null;
      private String subparent=null;
      private Vector listener=new Vector();
--- 44,50 ----
   *
   * @author thorsten.hell@cismet.de
   */
! public class WMSCapabilitiesTreeModel implements TreeModel{
      private WMSCapabilities capabilities=null;
      private String subparent=null;
      private Vector listener=new Vector();
Index: de/cismet/cismap/commons/raster/wms/WMSServiceLayer.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/raster/wms/WMSServiceLayer.java,v
retrieving revision 1.22.4.1
diff -c -r1.22.4.1 WMSServiceLayer.java
*** de/cismet/cismap/commons/raster/wms/WMSServiceLayer.java	1 Oct 2008 09:30:57 -0000	1.22.4.1
--- de/cismet/cismap/commons/raster/wms/WMSServiceLayer.java	19 Mar 2009 14:56:42 -0000
***************
*** 174,181 ****
              }
              if(wmsCaps != null){
                  Layer l=searchForLayer(getWmsCapabilities().getCapability().getLayer(),name);
!                 
!                 
                  
                  Style style=null;
                  if (styleName!=null) {
--- 174,182 ----
              }
              if(wmsCaps != null){
                  Layer l=searchForLayer(getWmsCapabilities().getCapability().getLayer(),name);
!                 if (layerList.size()==1){
!                     setName(l.getTitle());
!                 }
                  
                  Style style=null;
                  if (styleName!=null) {
***************
*** 246,252 ****
                  //macht nix
                  //mehrfachaufruf mit der gleichen url = unsinn
                  log.debug("mehrfachaufruf mit der gleichen url = unsinn");
!             } else {                
                  if (ir!=null&&ir.isAlive()) {
                      //log.fatal("Versuche den vorherigen Retrievalprozess zu stoppen. (interrupt())");
                      ir.youngerWMSCall();
--- 247,253 ----
                  //macht nix
                  //mehrfachaufruf mit der gleichen url = unsinn
                  log.debug("mehrfachaufruf mit der gleichen url = unsinn");
!             } else {
                  if (ir!=null&&ir.isAlive()) {
                      //log.fatal("Versuche den vorherigen Retrievalprozess zu stoppen. (interrupt())");
                      ir.youngerWMSCall();
***************
*** 255,261 ****
                      retrievalAborted(new RetrievalEvent());
                  }
                  ir=new ImageRetrieval(this);
-                 log.debug("getMapURL(): "+getGetMapUrl());
                  ir.setUrl(getGetMapUrl());
                  //new
                  ir.setWMSCapabilities(getWmsCapabilities());
--- 256,261 ----
***************
*** 305,311 ****
          this.srs = srs;
      }
      
!     private String getGetMapUrl() {        
          String url=getGetMapPrefix();
          
          if (bb!=null &&url != null) {
--- 305,311 ----
          this.srs = srs;
      }
      
!     private String getGetMapUrl() {
          String url=getGetMapPrefix();
          
          if (bb!=null &&url != null) {
***************
*** 327,338 ****
              url+="&BGCOLOR="+getBackgroundColor();
              url+="&EXCEPTIONS="+exceptionsFormat;
              url+=getLayersString(wmsLayers);
!             url+=getStylesString(wmsLayers);            
              return url;
!         } else {            
              return null;
          }
-         
      }
      public String getGetFeatureInfoUrl(int x,int y,WMSLayer l) {
          String url=getGetFeatureInfoPrefix();
--- 327,337 ----
              url+="&BGCOLOR="+getBackgroundColor();
              url+="&EXCEPTIONS="+exceptionsFormat;
              url+=getLayersString(wmsLayers);
!             url+=getStylesString(wmsLayers);
              return url;
!         } else {
              return null;
          }
      }
      public String getGetFeatureInfoUrl(int x,int y,WMSLayer l) {
          String url=getGetFeatureInfoPrefix();
***************
*** 354,360 ****
              url+="&FORMAT="+imageFormat;
              url+="&TRANSPARENT="+new Boolean(transparentImage).toString().toUpperCase();
              url+="&BGCOLOR="+backgroundColor;
!             url+="&EXCEPTIONS="+"text/html";//exceptionsFormat;
              url+=getLayersString(wmsLayers);
              url+=getStylesString(wmsLayers);
              url+="&QUERY_LAYERS="+l.getOgcCapabilitiesLayer().getName();
--- 353,359 ----
              url+="&FORMAT="+imageFormat;
              url+="&TRANSPARENT="+new Boolean(transparentImage).toString().toUpperCase();
              url+="&BGCOLOR="+backgroundColor;
!             //url+="&EXCEPTIONS="+"text/html";//exceptionsFormat;
              url+=getLayersString(wmsLayers);
              url+=getStylesString(wmsLayers);
              url+="&QUERY_LAYERS="+l.getOgcCapabilitiesLayer().getName();
***************
*** 367,400 ****
          }
      }
      
!     private String getGetMapPrefix() {        
!         try {            
!             Operation op=getWmsCapabilities().getCapability().getRequest().getOperation(Operation.MAP);            
              Object o=null;
              String prefix=null;
!             if (op==null) {                
!                 op=getWmsCapabilities().getCapability().getRequest().getOperation(Operation.GETMAP);                
              }
              
              if (op!=null) {
!                 o=op.getDCPTypes()[0].getProtocol();                
              }
-             if (o instanceof HTTP_Impl){                
-                 //ToDo UGLY WINNING WSS schneidet wenn es get und post gibt das geht.
-                 if(((HTTP_Impl)o).getGetOnlineResources().length !=0){
-                     prefix=((HTTP_Impl)o).getGetOnlineResources()[0].toString();
-                 } else if(((HTTP_Impl)o).getPostOnlineResources().length!=0){                    
-                     prefix=((HTTP_Impl)o).getPostOnlineResources()[0].toString();
-                 } else {                    
-                     return null;
-                 }                
-             }            
              return prefix;
!         } catch (Throwable npe){
!             log.warn("Throwable in getMapPrefix",npe);            
              return null;
          }
-         
      }
      private String getGetFeatureInfoPrefix() {
          try {
--- 366,395 ----
          }
      }
      
!     
!     
!     
!     private String getGetMapPrefix() {
!         try {
!             Operation op=getWmsCapabilities().getCapability().getRequest().getOperation(Operation.MAP);
              Object o=null;
              String prefix=null;
!             if (op==null) {
!                 op=getWmsCapabilities().getCapability().getRequest().getOperation(Operation.GETMAP);
              }
              
              if (op!=null) {
!                 o=op.getDCPTypes()[0].getProtocol();
!             }
!             if (o instanceof HTTP_Impl){
!                 prefix=((HTTP_Impl)o).getGetOnlineResources()[0].toString();
!                 
              }
              return prefix;
!         } catch (NullPointerException npe){
!             log.warn("NPE in getGetMapPrefix()",npe);
              return null;
          }
      }
      private String getGetFeatureInfoPrefix() {
          try {
Index: de/cismet/cismap/commons/raster/wms/simple/SimpleWMS.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/raster/wms/simple/SimpleWMS.java,v
retrieving revision 1.12
retrieving revision 1.13
diff -c -r1.12 -r1.13
*** de/cismet/cismap/commons/raster/wms/simple/SimpleWMS.java	28 May 2008 07:51:11 -0000	1.12
--- de/cismet/cismap/commons/raster/wms/simple/SimpleWMS.java	21 Nov 2008 15:45:16 -0000	1.13
***************
*** 43,48 ****
--- 43,49 ----
  import org.jdom.Attribute;
  import org.jdom.Element;
  import java.util.Vector;
+ import org.apache.commons.httpclient.HttpClient;
  import org.jdom.CDATA;
  
  /**
***************
*** 56,61 ****
--- 57,63 ----
      private ImageRetrieval ir;
      private PNode pNode;
      private String name = "SimpleWMS";
+     private HttpClient preferredClient=null;
  
      /**
       * Creates a new instance of SimpleWMS 
***************
*** 161,166 ****
--- 163,169 ----
  //                }
              }
              ir = new ImageRetrieval(this);
+             ir.setPreferredHttpClient(preferredClient);
              ir.setUrl(gmUrl.toString());
              log.debug("ir.start();");
              ir.setPriority(Thread.NORM_PRIORITY);
***************
*** 199,202 ****
--- 202,214 ----
      public String toString() {
          return getName();
      }
+ 
+     public HttpClient getPreferredClient() {
+         return preferredClient;
+     }
+ 
+     public void setPreferredClient(HttpClient preferredClient) {
+         this.preferredClient = preferredClient;
+     }
+     
  }
Index: de/cismet/cismap/commons/rasterservice/GUICredentialsProvider.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/rasterservice/GUICredentialsProvider.java,v
retrieving revision 1.13
diff -c -r1.13 GUICredentialsProvider.java
*** de/cismet/cismap/commons/rasterservice/GUICredentialsProvider.java	27 Sep 2007 15:08:23 -0000	1.13
--- de/cismet/cismap/commons/rasterservice/GUICredentialsProvider.java	19 Mar 2009 14:56:42 -0000
***************
*** 27,37 ****
  import org.apache.commons.httpclient.auth.NTLMScheme;
  import org.apache.commons.httpclient.auth.RFC2617Scheme;
  import org.apache.commons.httpclient.methods.GetMethod;
! import org.jdesktop.swingx.JXLoginPanel;
  import org.jdesktop.swingx.JXPanel;
  import org.jdesktop.swingx.auth.DefaultUserNameStore;
  import org.jdesktop.swingx.auth.LoginService;
  
  /**
   *
   * @author Sebastian
--- 27,40 ----
  import org.apache.commons.httpclient.auth.NTLMScheme;
  import org.apache.commons.httpclient.auth.RFC2617Scheme;
  import org.apache.commons.httpclient.methods.GetMethod;
! 
! import org.jdesktop.swingx.JXLoginPane;
! import org.jdesktop.swingx.JXLoginPane.JXLoginDialog;
  import org.jdesktop.swingx.JXPanel;
  import org.jdesktop.swingx.auth.DefaultUserNameStore;
  import org.jdesktop.swingx.auth.LoginService;
  
+ 
  /**
   *
   * @author Sebastian
***************
*** 125,131 ****
      }
      
      private void requestUsernamePassword() throws CredentialsNotAvailableException{
!         JXLoginPanel login = new JXLoginPanel(this,null,usernames);
          
          String[] names = usernames.getUserNames();
          if(names.length!=0){
--- 128,134 ----
      }
      
      private void requestUsernamePassword() throws CredentialsNotAvailableException{
!         JXLoginPane login = new JXLoginPane(this,null,usernames);
          
          String[] names = usernames.getUserNames();
          if(names.length!=0){
***************
*** 152,158 ****
                      );
          }
          log.debug("parentFrame in GUICredentialprovider:"+parent);
!         JXLoginPanel.JXLoginDialog dialog = new JXLoginPanel.JXLoginDialog((JFrame)parent,login);
          
          try {
              ((JXPanel)((JXPanel)login.getComponent(1)).getComponent(1)).getComponent(3).requestFocus();
--- 155,161 ----
                      );
          }
          log.debug("parentFrame in GUICredentialprovider:"+parent);
!         JXLoginPane.JXLoginDialog dialog = new JXLoginPane.JXLoginDialog((JFrame)parent,login);
          
          try {
              ((JXPanel)((JXPanel)login.getComponent(1)).getComponent(1)).getComponent(3).requestFocus();
Index: de/cismet/cismap/commons/rasterservice/HTTPImageRetrieval.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/rasterservice/HTTPImageRetrieval.java,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -r1.4 -r1.5
*** de/cismet/cismap/commons/rasterservice/HTTPImageRetrieval.java	2 Feb 2007 10:19:49 -0000	1.4
--- de/cismet/cismap/commons/rasterservice/HTTPImageRetrieval.java	2 Dec 2008 15:09:09 -0000	1.5
***************
*** 31,37 ****
   * Created on 7. August 2006, 15:39
   *
   */
- 
  package de.cismet.cismap.commons.rasterservice;
  
  import de.cismet.cismap.commons.retrieval.RetrievalEvent;
--- 31,36 ----
***************
*** 53,102 ****
   *
   * @author thorsten.hell@cismet.de
   */
! public class HTTPImageRetrieval extends Thread{
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
!     private RetrievalListener listener=null;
      private ImageObserverInterceptor observer;
!     Image image=null;
      HttpClient client;
      GetMethod method;
      String url;
!     private ByteArrayOutputStream byteArrayOut=null;
!     private boolean youngerCall=false;
      /** Creates a new instance of HTTPImageRetrieval */
      public HTTPImageRetrieval(RetrievalListener listener) {
!         this.listener=listener;
          client = new HttpClient();
          //client.getHostConfiguration().setProxy("www-proxy.htw-saarland.de", 3128);
          String proxySet = System.getProperty("proxySet");
!         if(proxySet != null && proxySet.equals("true")){
              log.debug("proxyIs Set");
!             log.debug("ProxyHost:"+System.getProperty("http.proxyHost"));
!             log.debug("ProxyPort:"+System.getProperty("http.proxyPort"));
              try {
!             client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));    
!             } catch(Exception e){
!                 log.error("Problem while setting proxy",e);
              }
!         }                        
      }
!     
      public void run() {
!         if (method!=null) {
              method.abort();
          }
!         method = new GetMethod( url );
          if (!method.isAborted()) {
              try {
!                 int statusCode = client.executeMethod( method );
!                 
!                 if( statusCode != -1 ) {
!                     log.debug("reading: "+url);
                      InputStream is = method.getResponseBodyAsStream();
!                     BufferedInputStream in = new BufferedInputStream( is );
                      byteArrayOut = new ByteArrayOutputStream();
                      int c;
!                     
                      while ((c = in.read()) != -1) {
                          byteArrayOut.write(c);
                          if (youngerCall) {
--- 52,114 ----
   *
   * @author thorsten.hell@cismet.de
   */
! public class HTTPImageRetrieval extends Thread {
! 
      private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
!     private RetrievalListener listener = null;
      private ImageObserverInterceptor observer;
!     Image image = null;
      HttpClient client;
      GetMethod method;
      String url;
!     private ByteArrayOutputStream byteArrayOut = null;
!     private boolean youngerCall = false;
! 
      /** Creates a new instance of HTTPImageRetrieval */
      public HTTPImageRetrieval(RetrievalListener listener) {
!         this.listener = listener;
          client = new HttpClient();
          //client.getHostConfiguration().setProxy("www-proxy.htw-saarland.de", 3128);
+ 
+         log.debug("proxySet:" + System.getProperty("http.proxyHost"));
+         log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
+         log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
+ 
+ 
+ 
          String proxySet = System.getProperty("proxySet");
!         if (proxySet != null && proxySet.equals("true")) {
              log.debug("proxyIs Set");
!             log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
!             log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
              try {
!                 client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));
!             } catch (Exception e) {
!                 log.error("Problem while setting proxy", e);
              }
!         }
!         else {
!             log.debug("no proxyIs Set");
!         }
! 
      }
! 
      public void run() {
!         if (method != null) {
              method.abort();
          }
!         method = new GetMethod(url);
          if (!method.isAborted()) {
              try {
!                 int statusCode = client.executeMethod(method);
! 
!                 if (statusCode != -1) {
!                     log.debug("reading: " + url);
                      InputStream is = method.getResponseBodyAsStream();
!                     BufferedInputStream in = new BufferedInputStream(is);
                      byteArrayOut = new ByteArrayOutputStream();
                      int c;
! 
                      while ((c = in.read()) != -1) {
                          byteArrayOut.write(c);
                          if (youngerCall) {
***************
*** 105,118 ****
                              return;
                          }
                      }
!                     
                      log.debug("creating image");
                      //Image image =observer.createImage( (ImageProducer) o);
!                     observer=new ImageObserverInterceptor();
                      //Image image =Toolkit.getDefaultToolkit().getImage(is);
!                     image=Toolkit.getDefaultToolkit().createImage(byteArrayOut.toByteArray());
                      observer.prepareImage(image, observer);
!                     while ((observer.checkImage(image, observer) & observer.ALLBITS)!= observer.ALLBITS) {
                          Thread.sleep(10);
                          if (youngerCall) {
                              fireLoadingAborted();
--- 117,130 ----
                              return;
                          }
                      }
! 
                      log.debug("creating image");
                      //Image image =observer.createImage( (ImageProducer) o);
!                     observer = new ImageObserverInterceptor();
                      //Image image =Toolkit.getDefaultToolkit().getImage(is);
!                     image = Toolkit.getDefaultToolkit().createImage(byteArrayOut.toByteArray());
                      observer.prepareImage(image, observer);
!                     while ((observer.checkImage(image, observer) & observer.ALLBITS) != observer.ALLBITS) {
                          Thread.sleep(10);
                          if (youngerCall) {
                              fireLoadingAborted();
***************
*** 120,127 ****
                              return;
                          }
                      }
!                     
!                     RetrievalEvent e=new RetrievalEvent();
                      e.setIsComplete(true);
                      e.setRetrievedObject(image);
                      if (!youngerCall) {
--- 132,139 ----
                              return;
                          }
                      }
! 
!                     RetrievalEvent e = new RetrievalEvent();
                      e.setIsComplete(true);
                      e.setRetrievedObject(image);
                      if (!youngerCall) {
***************
*** 131,198 ****
                          fireLoadingAborted();
                      }
                      method.releaseConnection();
!                     
                  }
!             } catch( Exception e ) {
                  e.printStackTrace();
              }
          }
      }
      public String getUrl() {
          return url;
      }
!     
      public void setUrl(String url) {
          this.url = url;
!         
      }
      public void endRetrieval() {
!         if (method!=null) {
              method.abort();
          }
!         youngerCall=true;
      }
!     
!     
!     
!     public void fireLoadingAborted(){
          log.info("Retrieval unterbrochen");
!         if (method!=null&&!method.isAborted()) {
              method.abort();
          }
!         image=null;
!         observer=null;
!         
          System.gc();
      }
      private class ImageObserverInterceptor extends JComponent {
          public boolean imageUpdate(Image img,
                  int infoflags,
                  int x,
                  int y,
                  int width,
                  int height) {
!             boolean ret=super.imageUpdate(img,infoflags,x,y,width,height);
  //            log.debug("ImageUpdate");
  //            log.debug("y "+height);
  //            log.debug("img.getHeight"+img.getHeight(this));
!             
!             
!             if ((infoflags&ImageObserver.SOMEBITS) !=0) {
!                 RetrievalEvent e=new RetrievalEvent();
!                 e.setPercentageDone((double)y/(img.getHeight(this)-1.0)*100);
                  listener.retrievalProgress(e);
!             } else if ((infoflags&ImageObserver.ABORT)!=0) {
!                 
!             } else if ((infoflags&ImageObserver.ERROR)!=0) {
!                 RetrievalEvent e=new RetrievalEvent();
                  e.setHasErrors(true);
!                 String error=new String(byteArrayOut.toByteArray());
                  e.setRetrievedObject(error);
                  listener.retrievalError(e);
              }
              return ret;
          }
      }
-     
  }
--- 143,210 ----
                          fireLoadingAborted();
                      }
                      method.releaseConnection();
! 
                  }
!             } catch (Exception e) {
                  e.printStackTrace();
              }
          }
      }
+ 
      public String getUrl() {
          return url;
      }
! 
      public void setUrl(String url) {
          this.url = url;
! 
      }
+ 
      public void endRetrieval() {
!         if (method != null) {
              method.abort();
          }
!         youngerCall = true;
      }
! 
!     public void fireLoadingAborted() {
          log.info("Retrieval unterbrochen");
!         if (method != null && !method.isAborted()) {
              method.abort();
          }
!         image = null;
!         observer = null;
! 
          System.gc();
      }
+ 
      private class ImageObserverInterceptor extends JComponent {
+ 
          public boolean imageUpdate(Image img,
                  int infoflags,
                  int x,
                  int y,
                  int width,
                  int height) {
!             boolean ret = super.imageUpdate(img, infoflags, x, y, width, height);
  //            log.debug("ImageUpdate");
  //            log.debug("y "+height);
  //            log.debug("img.getHeight"+img.getHeight(this));
! 
! 
!             if ((infoflags & ImageObserver.SOMEBITS) != 0) {
!                 RetrievalEvent e = new RetrievalEvent();
!                 e.setPercentageDone((double) y / (img.getHeight(this) - 1.0) * 100);
                  listener.retrievalProgress(e);
!             } else if ((infoflags & ImageObserver.ABORT) != 0) {
!             } else if ((infoflags & ImageObserver.ERROR) != 0) {
!                 RetrievalEvent e = new RetrievalEvent();
                  e.setHasErrors(true);
!                 String error = new String(byteArrayOut.toByteArray());
                  e.setRetrievedObject(error);
                  listener.retrievalError(e);
              }
              return ret;
          }
      }
  }
Index: de/cismet/cismap/commons/rasterservice/HttpAuthentication.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/rasterservice/HttpAuthentication.java,v
retrieving revision 1.14.4.1
retrieving revision 1.16
diff -c -r1.14.4.1 -r1.16
*** de/cismet/cismap/commons/rasterservice/HttpAuthentication.java	1 Oct 2008 09:30:57 -0000	1.14.4.1
--- de/cismet/cismap/commons/rasterservice/HttpAuthentication.java	2 Dec 2008 15:09:09 -0000	1.16
***************
*** 6,19 ****
   * To change this template, choose Tools | Template Manager
   * and open the template in the editor.
   */
- 
  package de.cismet.cismap.commons.rasterservice;
  
  import de.cismet.cismap.commons.exceptions.AuthenticationCanceledException;
  import de.cismet.cismap.commons.exceptions.BadHttpStatusCodeException;
  import de.cismet.cismap.commons.exceptions.CannotReadFromURLException;
  import de.cismet.cismap.commons.interaction.CismapBroker;
- import java.awt.Component;
  import java.io.BufferedInputStream;
  import java.io.InputStreamReader;
  import java.net.URL;
--- 6,17 ----
***************
*** 31,290 ****
   * @author Sebastian
   */
  public class HttpAuthentication {
!     
! //    //private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
! //    private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger("de.cismet.cismap.commons.rasterservice.HttpAuthentication");
! //    
! //    /** Creates a new instance of HttpAuthentication */
! //    private HttpAuthentication() {
! //    }
! //    
! //    /*@author Sebastian
! //     * added 18.10.06 for http authentication support
! //     */
! //    
! //    public static InputStreamReader getInputStreamReaderFromURL(Component parent,URL url,GetMethod method) throws Exception{
! //        HttpClient client = new HttpClient();
! //        //client.getHostConfiguration().setProxy(System.getProperty("proxyHost"), Integer.getInteger(System.getProperty("proxyPort")));
! //        //client.getHostConfiguration().setProxy("www-proxy.htw-saarland.de", 3128);        
! //        //client.getHostConfiguration().setProxy(System.getProperty("proxyHost"), Integer.getInteger(System.getProperty("proxyPort")));
! //        
! //        String proxySet = System.getProperty("proxySet");
! //        if(proxySet != null && proxySet.equals("true")){
! //            log.debug("proxyIs Set");
! //            log.debug("ProxyHost:"+System.getProperty("http.proxyHost"));
! //            log.debug("ProxyPort:"+System.getProperty("http.proxyPort"));
! //            try {
! //            client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));    
! //            } catch(Exception e){
! //                log.error("Problem while setting proxy",e);
! //            }
! //        }
! //        log.debug("Trying to receive InputStreamReader from URL: "+url.toString());
! //        CismapBroker broker = CismapBroker.getInstance();
! //        //GetMethod method = new GetMethod(url.toString());
! //        method.setURI(new URI(url.toString(),false,null));
! //        
! //        GUICredentialsProvider cp = broker.getHttpCredentialProviderURL(url);
! //        log.debug("Retrieving Credential Provider for url: "+url.toString());
! //        if(cp != null){
! //            log.debug("Credential Provider available for ... " + url.toString());
! //            client.getParams().setParameter(CredentialsProvider.PROVIDER,cp);
! //        } else {
! //            cp = broker.createSynchronizedCP(url,parent);
! //            client.getParams().setParameter(CredentialsProvider.PROVIDER,cp);
! //        }
! //        
! //        method.setDoAuthentication(true);
! //        int statuscode;
! //        boolean isRequesting = true;
! //        
! //        while(isRequesting){
! //            log.debug("Executing GET for ... " + url.toString());
! //            statuscode = client.executeMethod(method);
! //            
! //            if(cp.isAuthenticationCanceled()){
! //                log.debug("User has canceled the Authorization for ... "+url.toString());
! //                throw new AuthenticationCanceledException();
! //            }
! //            switch (statuscode){
! //                case(HttpStatus.SC_UNAUTHORIZED):
! //                    log.debug("Server response: credentials are not valid (statuscode 401) for ... "+url.toString());
! //                    continue;
! //                case(HttpStatus.SC_OK):
! //                    log.debug("server response:  ok (statuscode 200) for ... "+url.toString());
! //                    return new InputStreamReader(new BufferedInputStream(method.getResponseBodyAsStream()));
! //                default:
! //                    log.error("Statuscode is unknown and not implemented for ... "+url.toString() +" statuscode: "+statuscode);
! //                    throw new BadHttpStatusCodeException("Bad statuscode from server",statuscode);
! //            }
! //        }
! //        log.error("Unable to read form URL :"+url.toString());
! //        throw new CannotReadFromURLException("Error during retrieving data from URL");
! //    }
! //    
! //    public static InputStreamReader getInputStreamReaderFromURL(Component parent,URL url) throws Exception{
! //        return getInputStreamReaderFromURL(parent,url,new GetMethod());
! //    }
! //    
! //    
! //    
! //    public static BufferedInputStream getBufferedInputStreamFromCapabilities(Component parent,WMSCapabilities cap,URL url,GetMethod method) throws Exception{
! //        HttpClient client = new HttpClient();
! //        //client.getHostConfiguration().setProxy("www-proxy.htw-saarland.de", 3128);
! //        //client.getHostConfiguration().setProxy(System.getProperty("proxyHost"), Integer.getInteger(System.getProperty("proxyPort")));
! //        String proxySet = System.getProperty("proxySet");
! //        if(proxySet != null && proxySet.equals("true")){
! //            log.debug("proxyIs Set");
! //            log.debug("ProxyHost:"+System.getProperty("http.proxyHost"));
! //            log.debug("ProxyPort:"+System.getProperty("http.proxyPort"));
! //            try {
! //            client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));    
! //            } catch(Exception e){
! //                log.error("Problem while setting proxy",e);
! //            }
! //        }
! //        log.debug("Trying to receive BufferedInputStream from URL: "+url.toString()+" with capabilities");
! //        CismapBroker broker = CismapBroker.getInstance();
! //        GUICredentialsProvider cp;
! //        cp = broker.getHttpCredentialProviderCapabilities(cap);
! //        log.debug("Retrieving Credential Provider for url: "+url.toString());
! //        //GetMethod method = new GetMethod(url.toString());
! //        method.setURI(new URI(url.toString(),false,null));
! //        //if(cp.isAuthenticationCanceled())throw new AuthenticationCanceledException();
! //        if(cp != null){
! //            log.debug("Credential Provider available for ... " + url.toString());
! //            client.getParams().setParameter(CredentialsProvider.PROVIDER,cp);
! //        } else {
! //            cp = broker.createSynchronizedCP(url,parent,cap);
! //            client.getParams().setParameter(CredentialsProvider.PROVIDER,cp);
! //        }
! //        
! //        
! //        method.setDoAuthentication(true);
! //        int statuscode;
! //        boolean isRequesting = true;
! //        
! //        while(isRequesting){
! //            log.debug("Executing GET for ... " + url.toString());
! //            statuscode = client.executeMethod(method);
! //            if(cp.isAuthenticationCanceled()){
! //                log.debug("User has canceled the Authorization for ... "+url.toString());
! //                throw new AuthenticationCanceledException();
! //            }
! //            switch (statuscode){
! //                case(HttpStatus.SC_UNAUTHORIZED):
! //                    log.debug("Server response: credentials are not valid (statuscode 401) for ... "+url.toString());
! //                    continue;
! //                case(HttpStatus.SC_OK):
! //                    log.debug("Server response:  ok (statuscode 200) for ... "+url.toString());
! //                    return new BufferedInputStream(method.getResponseBodyAsStream());
! //                default:
! //                    log.error("Statuscode is unknown and not implemented for ... "+url.toString() +" statuscode: "+statuscode);
! //                    throw new BadHttpStatusCodeException("Bad statuscode from server",statuscode);
! //            }
! //        }
! //        log.error("Unable to read form URL :"+url.toString());
! //        throw new CannotReadFromURLException("Error during retrieving data from URL");
! //        
! //    }
! //    
! //    /*@author Sebastian
! //     * added 18.10.06 for http authentication support
! //     */
! //    public static BufferedInputStream getBufferedInputStreamFromCapabilities(Component parent,WMSCapabilities cap,URL url) throws Exception{
! //        return getBufferedInputStreamFromCapabilities(parent,cap,url,new GetMethod());
! //    }
! //    
! //    public static BufferedInputStream getBufferedInputStreamFromCapabilities(WMSCapabilities cap,URL url,GetMethod method) throws Exception{
! //        HttpClient client = new HttpClient();
! //        String proxySet = System.getProperty("proxySet");
! //        if(proxySet != null && proxySet.equals("true")){
! //            log.debug("proxyIs Set");
! //            log.debug("ProxyHost:"+System.getProperty("http.proxyHost"));
! //            log.debug("ProxyPort:"+System.getProperty("http.proxyPort"));
! //            try {
! //            client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));    
! //            } catch(Exception e){
! //                log.error("Problem while setting proxy",e);
! //            }
! //        }
! //        log.debug("Trying to receive BufferedInputStream from URL: "+url.toString()+" with capabilities");
! //        
! //        CismapBroker broker = CismapBroker.getInstance();
! //        GUICredentialsProvider cp;
! //        cp = broker.getHttpCredentialProviderCapabilities(cap);
! //        log.debug("Retrieving Credential Provider for capability: "+cap.getCapability().getLayer().getTitle() +" (url: "+url.toString()+")");
! //        //GetMethod method = new GetMethod(url.toString());
! //        method.setURI(new URI(url.toString(),true,null));
! //        //if(cp.isAuthenticationCanceled())throw new AuthenticationCanceledException();
! //        if(cp != null){
! //            log.debug("Credential Provider available for ... " + cap.getCapability().getLayer().getTitle());
! //            client.getParams().setParameter(CredentialsProvider.PROVIDER,cp);
! //        } else {
! //            cp = broker.createSynchronizedCP(url,cap);
! //            client.getParams().setParameter(CredentialsProvider.PROVIDER,cp);
! //        }
! //        
! //        
! //        method.setDoAuthentication(true);
! //        int statuscode;
! //        boolean isRequesting = true;
! //        
! //        while(isRequesting){
! //            log.debug("Executing GET for ... " + url.toString());
! //            statuscode = client.executeMethod(method);
! //            if(cp.isAuthenticationCanceled()){
! //                log.debug("User has canceled the Authorization for ... "+url.toString());
! //                throw new AuthenticationCanceledException();
! //            }
! //            switch (statuscode){
! //                case(HttpStatus.SC_UNAUTHORIZED):
! //                    log.debug("Server response: credentials are not valid (statuscode 401) for ... "+url.toString());
! //                    continue;
! //                case(HttpStatus.SC_OK):
! //                    log.debug("Server response:  ok (statuscode 200) for ... "+url.toString());
! //                    return new BufferedInputStream(method.getResponseBodyAsStream());
! //                default:
! //                    log.error("Statuscode is unknown and not implemented for ... "+url.toString() +" statuscode: "+statuscode);
! //                    throw new BadHttpStatusCodeException("Bad statuscode from server",statuscode);
! //            }
! //        }
! //        log.error("Unable to read form URL :"+url.toString());
! //        throw new CannotReadFromURLException("Error during retrieving data from URL");
! //    }
! //    
! //    public static BufferedInputStream getBufferedInputStreamFromCapabilities(WMSCapabilities cap,URL url) throws Exception{
! //        return getBufferedInputStreamFromCapabilities(cap,url,new GetMethod());
! //    }
! //    
! //        public static BufferedInputStream getBufferedInputStreamFromURL(URL url,GetMethod method) throws Exception{
! //        HttpClient client = new HttpClient();
! //        String proxySet = System.getProperty("proxySet");
! //        if(proxySet != null && proxySet.equals("true")){
! //            log.debug("proxyIs Set");
! //            log.debug("ProxyHost:"+System.getProperty("http.proxyHost"));
! //            log.debug("ProxyPort:"+System.getProperty("http.proxyPort"));
! //            try {
! //            client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));    
! //            } catch(Exception e){
! //                log.error("Problem while setting proxy",e);
! //            }
! //        }
! //            CismapBroker broker = CismapBroker.getInstance();
! //        GUICredentialsProvider cp;
! //        cp = broker.getHttpCredentialProviderURL(url);
! //        //GetMethod method = new GetMethod(url.toString());
! //        method.setURI(new URI(url.toString(),false,null));
! //        //if(cp.isAuthenticationCanceled())throw new AuthenticationCanceledException();
! //        if(cp != null){
! //            client.getParams().setParameter(CredentialsProvider.PROVIDER,cp);
! //        } else {
! //            cp = broker.createSynchronizedCP(url);
! //            client.getParams().setParameter(CredentialsProvider.PROVIDER,cp);
! //        }
! //        
! //        method.setDoAuthentication(true);
! //        int statuscode;
! //        boolean isRequesting = true;
! //        
! //        //TODO ugly never used ?!
! //        while(isRequesting){
! //            statuscode = client.executeMethod(method);
! //            if(cp.isAuthenticationCanceled())throw new AuthenticationCanceledException();
! //            switch (statuscode){
! //                case(HttpStatus.SC_UNAUTHORIZED):
! //                    continue;
! //                case(HttpStatus.SC_OK):
! //                    return new BufferedInputStream(method.getResponseBodyAsStream());
! //                default:
! //                    throw new BadHttpStatusCodeException("Bad statuscode from server",statuscode);
! //            }
! //        }
! //        throw new CannotReadFromURLException("Error during retrieving data from URL");
! //        }
! //    
! //    public static BufferedInputStream getBufferedInputStreamFromURL(URL url) throws Exception{
! //        return getBufferedInputStreamFromURL(url,new GetMethod());
! //    }
  }
--- 29,316 ----
   * @author Sebastian
   */
  public class HttpAuthentication {
!     //private final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(this.getClass());
!     private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger("de.cismet.cismap.commons.rasterservice.HttpAuthentication");
! 
!     /** Creates a new instance of HttpAuthentication */
!     private HttpAuthentication() {
!     }
! 
!     /*@author Sebastian
!      * added 18.10.06 for http authentication support
!      */
!     public static InputStreamReader getInputStreamReaderFromURL(JComponent parent, URL url, GetMethod method) throws Exception {
!         HttpClient client = new HttpClient();
!         //client.getHostConfiguration().setProxy(System.getProperty("proxyHost"), Integer.getInteger(System.getProperty("proxyPort")));
!         //client.getHostConfiguration().setProxy("www-proxy.htw-saarland.de", 3128);        
!         //client.getHostConfiguration().setProxy(System.getProperty("proxyHost"), Integer.getInteger(System.getProperty("proxyPort")));
! 
!         String proxySet = System.getProperty("proxySet");
!         if (proxySet != null && proxySet.equals("true")) {
!             log.debug("proxyIs Set");
!             log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
!             log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
!             try {
!                 client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));
!             } catch (Exception e) {
!                 log.error("Problem while setting proxy", e);
!             }
!         }
!         log.debug("Trying to receive InputStreamReader from URL: " + url.toString());
!         CismapBroker broker = CismapBroker.getInstance();
!         //GetMethod method = new GetMethod(url.toString());
!         method.setURI(new URI(url.toString(), false, null));
! 
!         GUICredentialsProvider cp = broker.getHttpCredentialProviderURL(url);
!         log.debug("Retrieving Credential Provider for url: " + url.toString());
!         if (cp != null) {
!             log.debug("Credential Provider available for ... " + url.toString());
!             client.getParams().setParameter(CredentialsProvider.PROVIDER, cp);
!         } else {
!             cp = broker.createSynchronizedCP(url, parent);
!             client.getParams().setParameter(CredentialsProvider.PROVIDER, cp);
!         }
! 
!         method.setDoAuthentication(true);
!         int statuscode;
!         boolean isRequesting = true;
! 
!         while (isRequesting) {
!             log.debug("Executing GET for ... " + url.toString());
!             statuscode = client.executeMethod(method);
! 
!             if (cp.isAuthenticationCanceled()) {
!                 log.debug("User has canceled the Authorization for ... " + url.toString());
!                 throw new AuthenticationCanceledException();
!             }
!             switch (statuscode) {
!                 case (HttpStatus.SC_UNAUTHORIZED):
!                     log.debug("Server response: credentials are not valid (statuscode 401) for ... " + url.toString());
!                     continue;
!                 case (HttpStatus.SC_OK):
!                     log.debug("server response:  ok (statuscode 200) for ... " + url.toString());
!                     return new InputStreamReader(new BufferedInputStream(method.getResponseBodyAsStream()));
!                 default:
!                     log.error("Statuscode is unknown and not implemented for ... " + url.toString() + " statuscode: " + statuscode);
!                     throw new BadHttpStatusCodeException("Bad statuscode from server", statuscode);
!             }
!         }
!         log.error("Unable to read form URL :" + url.toString());
!         throw new CannotReadFromURLException("Error during retrieving data from URL");
!     }
! 
!     public static InputStreamReader getInputStreamReaderFromURL(JComponent parent, URL url) throws Exception {
!         return getInputStreamReaderFromURL(parent, url, new GetMethod());
!     }
! 
!     public static BufferedInputStream getBufferedInputStreamFromCapabilities(JComponent parent, WMSCapabilities cap, URL url, GetMethod method) throws Exception {
!         HttpClient client = new HttpClient();
!         //client.getHostConfiguration().setProxy("www-proxy.htw-saarland.de", 3128);
!         //client.getHostConfiguration().setProxy(System.getProperty("proxyHost"), Integer.getInteger(System.getProperty("proxyPort")));
!         String proxySet = System.getProperty("proxySet");
!         if (proxySet != null && proxySet.equals("true")) {
!             log.debug("proxyIs Set");
!             log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
!             log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
!             try {
!                 client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));
!             } catch (Exception e) {
!                 log.error("Problem while setting proxy", e);
!             }
!         }
!         log.debug("Trying to receive BufferedInputStream from URL: " + url.toString() + " with capabilities");
!         CismapBroker broker = CismapBroker.getInstance();
!         GUICredentialsProvider cp;
!         cp = broker.getHttpCredentialProviderCapabilities(cap);
!         log.debug("Retrieving Credential Provider for url: " + url.toString());
!         //GetMethod method = new GetMethod(url.toString());
!         method.setURI(new URI(url.toString(), false, null));
!         //if(cp.isAuthenticationCanceled())throw new AuthenticationCanceledException();
!         if (cp != null) {
!             log.debug("Credential Provider available for ... " + url.toString());
!             client.getParams().setParameter(CredentialsProvider.PROVIDER, cp);
!         } else {
!             cp = broker.createSynchronizedCP(url, parent, cap);
!             client.getParams().setParameter(CredentialsProvider.PROVIDER, cp);
!         }
! 
! 
!         method.setDoAuthentication(true);
!         int statuscode;
!         boolean isRequesting = true;
! 
!         while (isRequesting) {
!             log.debug("Executing GET for ... " + url.toString());
!             statuscode = client.executeMethod(method);
!             if (cp.isAuthenticationCanceled()) {
!                 log.debug("User has canceled the Authorization for ... " + url.toString());
!                 throw new AuthenticationCanceledException();
!             }
!             switch (statuscode) {
!                 case (HttpStatus.SC_UNAUTHORIZED):
!                     log.debug("Server response: credentials are not valid (statuscode 401) for ... " + url.toString());
!                     continue;
!                 case (HttpStatus.SC_OK):
!                     log.debug("Server response:  ok (statuscode 200) for ... " + url.toString());
!                     return new BufferedInputStream(method.getResponseBodyAsStream());
!                 default:
!                     log.error("Statuscode is unknown and not implemented for ... " + url.toString() + " statuscode: " + statuscode);
!                     throw new BadHttpStatusCodeException("Bad statuscode from server", statuscode);
!             }
!         }
!         log.error("Unable to read form URL :" + url.toString());
!         throw new CannotReadFromURLException("Error during retrieving data from URL");
! 
!     }
! 
!     /*@author Sebastian
!      * added 18.10.06 for http authentication support
!      */
!     public static BufferedInputStream getBufferedInputStreamFromCapabilities(JComponent parent, WMSCapabilities cap, URL url) throws Exception {
!         return getBufferedInputStreamFromCapabilities(parent, cap, url, new GetMethod());
!     }
! 
!     public static BufferedInputStream getBufferedInputStreamFromCapabilities(WMSCapabilities cap, URL url, GetMethod method) throws Exception {
!         HttpClient client = new HttpClient();
!         String proxySet = System.getProperty("proxySet");
!         if (proxySet != null && proxySet.equals("true")) {
!             log.debug("proxyIs Set");
!             log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
!             log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
!             try {
!                 client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));
!             } catch (Exception e) {
!                 log.error("Problem while setting proxy", e);
!             }
!         }
!         log.debug("Trying to receive BufferedInputStream from URL: " + url.toString() + " with capabilities");
! 
!         CismapBroker broker = CismapBroker.getInstance();
!         GUICredentialsProvider cp;
!         cp = broker.getHttpCredentialProviderCapabilities(cap);
!         log.debug("Retrieving Credential Provider for capability: " + cap.getCapability().getLayer().getTitle() + " (url: " + url.toString() + ")");
!         //GetMethod method = new GetMethod(url.toString());
!         method.setURI(new URI(url.toString(), true, null));
!         //if(cp.isAuthenticationCanceled())throw new AuthenticationCanceledException();
!         if (cp != null) {
!             log.debug("Credential Provider available for ... " + cap.getCapability().getLayer().getTitle());
!             client.getParams().setParameter(CredentialsProvider.PROVIDER, cp);
!         } else {
!             cp = broker.createSynchronizedCP(url, cap);
!             client.getParams().setParameter(CredentialsProvider.PROVIDER, cp);
!         }
! 
! 
!         method.setDoAuthentication(true);
!         int statuscode;
!         boolean isRequesting = true;
! 
!         while (isRequesting) {
!             log.debug("Executing GET for ... " + url.toString());
!             statuscode = client.executeMethod(method);
!             if (cp.isAuthenticationCanceled()) {
!                 log.debug("User has canceled the Authorization for ... " + url.toString());
!                 throw new AuthenticationCanceledException();
!             }
!             switch (statuscode) {
!                 case (HttpStatus.SC_UNAUTHORIZED):
!                     log.debug("Server response: credentials are not valid (statuscode 401) for ... " + url.toString());
!                     continue;
!                 case (HttpStatus.SC_OK):
!                     log.debug("Server response:  ok (statuscode 200) for ... " + url.toString());
!                     return new BufferedInputStream(method.getResponseBodyAsStream());
!                 default:
!                     log.error("Statuscode is unknown and not implemented for ... " + url.toString() + " statuscode: " + statuscode);
!                     throw new BadHttpStatusCodeException("Bad statuscode from server", statuscode);
!             }
!         }
!         log.error("Unable to read form URL :" + url.toString());
!         throw new CannotReadFromURLException("Error during retrieving data from URL");
!     }
! 
!     public static BufferedInputStream getBufferedInputStreamFromCapabilities(WMSCapabilities cap, URL url) throws Exception {
!         return getBufferedInputStreamFromCapabilities(cap, url, new GetMethod());
!     }
! 
!     public static BufferedInputStream getBufferedInputStreamFromURL(URL url, GetMethod method) throws Exception {
!         return getBufferedInputStreamFromURL(url,method,null);
!      
!     }
! 
!     public static BufferedInputStream getBufferedInputStreamFromURL(URL url, GetMethod method, HttpClient preferredClient) throws Exception {
!         HttpClient client = new HttpClient();
! 
!         if (preferredClient != null) {
!             client.getState().addCookies(preferredClient.getState().getCookies());
!         }
! 
!         log.debug("proxySet:" + System.getProperty("proxySet"));
!         log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
!         log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
! 
!         String proxySet = System.getProperty("proxySet");
!         if (proxySet != null && proxySet.equals("true")) {
!             log.debug("proxyIs Set");
!             log.debug("ProxyHost:" + System.getProperty("http.proxyHost"));
!             log.debug("ProxyPort:" + System.getProperty("http.proxyPort"));
!             try {
!                 client.getHostConfiguration().setProxy(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort")));
!             } catch (Exception e) {
!                 log.error("Problem while setting proxy", e);
!             }
!         }
!         CismapBroker broker = CismapBroker.getInstance();
!         GUICredentialsProvider cp;
!         cp = broker.getHttpCredentialProviderURL(url);
!         //GetMethod method = new GetMethod(url.toString());
!         method.setURI(new URI(url.toString(), false, null));
!         //if(cp.isAuthenticationCanceled())throw new AuthenticationCanceledException();
!         if (cp != null) {
!             client.getParams().setParameter(CredentialsProvider.PROVIDER, cp);
!         } else {
!             cp = broker.createSynchronizedCP(url);
!             client.getParams().setParameter(CredentialsProvider.PROVIDER, cp);
!         }
! 
!         method.setDoAuthentication(true);
!         int statuscode;
!         boolean isRequesting = true;
! 
!         while (isRequesting) {
!             statuscode = client.executeMethod(method);
!             if (cp.isAuthenticationCanceled()) {
!                 throw new AuthenticationCanceledException();
!             }
!             log.debug("Statuscode:" + statuscode + "\n" + url);
!             switch (statuscode) {
!                 case (HttpStatus.SC_UNAUTHORIZED):
!                     continue;
!                 case (HttpStatus.SC_OK):
!                     return new BufferedInputStream(method.getResponseBodyAsStream());
!                 default:
!                     throw new BadHttpStatusCodeException("Bad statuscode from server", statuscode);
!             }
!         }
!         throw new CannotReadFromURLException("Error during retrieving data from URL");
!     }
! 
!     public static BufferedInputStream getBufferedInputStreamFromURL(URL url) throws Exception {
!         return getBufferedInputStreamFromURL(url, new GetMethod());
!     }
! 
!     public static boolean isServerSecuredByPassword(WMSCapabilities cap) {
!         CismapBroker broker = CismapBroker.getInstance();
!         GUICredentialsProvider cp;
!         cp = broker.getHttpCredentialProviderCapabilities(cap);
!         if (cp != null) {
!             UsernamePasswordCredentials creds = cp.getCredentials();
!             if (creds != null) {
!                 return true;
!             } else {
!                 return false;
!             }
!         } else {
!             return false;
!         }
!     }
  }
Index: de/cismet/cismap/commons/rasterservice/ImageRetrieval.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/rasterservice/ImageRetrieval.java,v
retrieving revision 1.16.4.3
retrieving revision 1.17
diff -c -r1.16.4.3 -r1.17
*** de/cismet/cismap/commons/rasterservice/ImageRetrieval.java	11 Feb 2009 13:11:53 -0000	1.16.4.3
--- de/cismet/cismap/commons/rasterservice/ImageRetrieval.java	21 Nov 2008 15:45:16 -0000	1.17
***************
*** 35,42 ****
  package de.cismet.cismap.commons.rasterservice;
  import de.cismet.cismap.commons.retrieval.RetrievalEvent;
  import de.cismet.cismap.commons.retrieval.RetrievalListener;
! import de.cismet.security.AccessHandler.ACCESS_METHODS;
! import de.cismet.security.WebAccessManager;
  import java.awt.Image;
  import java.awt.Toolkit;
  import java.awt.image.ImageObserver;
--- 35,41 ----
  package de.cismet.cismap.commons.rasterservice;
  import de.cismet.cismap.commons.retrieval.RetrievalEvent;
  import de.cismet.cismap.commons.retrieval.RetrievalListener;
! import java.awt.EventQueue;
  import java.awt.Image;
  import java.awt.Toolkit;
  import java.awt.image.ImageObserver;
***************
*** 47,52 ****
--- 46,52 ----
  import java.net.URL;
  import java.net.URLConnection;
  import javax.swing.JComponent;
+ import org.apache.commons.httpclient.HttpClient;
  import org.apache.commons.httpclient.methods.GetMethod;
  import org.deegree.services.wms.capabilities.WMSCapabilities;
  
***************
*** 64,69 ****
--- 64,70 ----
      private URLConnection uc=null;
      private InputStream is=null;
      private WMSCapabilities cap;
+     private HttpClient preferredHttpClient;
      /** Creates a new instance of ImageRetrieval */
      public ImageRetrieval(RetrievalListener listener) {
          this.listener=listener;
***************
*** 103,142 ****
              //is=uc.getInputStream();
              //BufferedInputStream in = new BufferedInputStream(is);
              
! //            if (getMethod==null) {
! //                getMethod=new GetMethod();
! //            }
! //            else {
! //                releaseConnection();
! //                getMethod=new GetMethod();
! //            }           
!             String urlBase = null;
!             String requestParameter = null;
!             int indexOfCharacter=0;
!             if((indexOfCharacter =url.indexOf('?')) != -1){
!                 urlBase = url.substring(0, indexOfCharacter);
!                 if(indexOfCharacter+1 < url.length()){
!                     requestParameter = url.substring(indexOfCharacter+1,url.length());
!                 }                
!             } else {
!                 urlBase = url;
!                 requestParameter="";
              }
              
              BufferedInputStream in;
              if(cap != null){
!                 //ToDO!!! checken ob HTTP AUTH noch funktioniert
!                 //in = new BufferedInputStream(HttpAuthentication.getBufferedInputStreamFromCapabilities(cap,u,getMethod));                
!                 in = new BufferedInputStream(WebAccessManager.getInstance().doRequest(new URL(urlBase), requestParameter, ACCESS_METHODS.GET_REQUEST));
              } else {
!                 //in = new BufferedInputStream(HttpAuthentication.getBufferedInputStreamFromURL(u,getMethod));
!                 in = new BufferedInputStream(WebAccessManager.getInstance().doRequest(new URL(urlBase), requestParameter, ACCESS_METHODS.GET_REQUEST));
              }
              
              byteArrayOut = new ByteArrayOutputStream();
              
              int c;
-             //ToDo performanz
              while ((c = in.read()) != -1) {
                  byteArrayOut.write(c);
                  if (youngerCall||isInterrupted()) {
--- 104,128 ----
              //is=uc.getInputStream();
              //BufferedInputStream in = new BufferedInputStream(is);
              
!             if (getMethod==null) {
!                 getMethod=new GetMethod();
!             }
!             else {
!                 releaseConnection();
!                 getMethod=new GetMethod();
              }
              
+             
              BufferedInputStream in;
              if(cap != null){
!                 in = new BufferedInputStream(HttpAuthentication.getBufferedInputStreamFromCapabilities(cap,u,getMethod));
              } else {
!                 in = new BufferedInputStream(HttpAuthentication.getBufferedInputStreamFromURL(u,getMethod,preferredHttpClient));
              }
              
              byteArrayOut = new ByteArrayOutputStream();
              
              int c;
              while ((c = in.read()) != -1) {
                  byteArrayOut.write(c);
                  if (youngerCall||isInterrupted()) {
***************
*** 174,180 ****
              }
              
          } catch ( Exception  e ) {
! //            log.error(byteArrayOut);
              RetrievalEvent re=new RetrievalEvent();
              re.setIsComplete(false);
              if (e.getMessage()==null||e.getMessage().equals("null")) {
--- 160,168 ----
              }
              
          } catch ( Exception  e ) {
! 
!            
!             log.error(byteArrayOut);
              RetrievalEvent re=new RetrievalEvent();
              re.setIsComplete(false);
              if (e.getMessage()==null||e.getMessage().equals("null")) {
***************
*** 232,237 ****
--- 220,233 ----
      public void setWMSCapabilities(WMSCapabilities cap){
          this.cap = cap;
      }
+ 
+     public HttpClient getPreferredHttpClient() {
+         return preferredHttpClient;
+     }
+ 
+     public void setPreferredHttpClient(HttpClient preferredHttpClient) {
+         this.preferredHttpClient = preferredHttpClient;
+     }
      
      
      
Index: de/cismet/cismap/commons/wfsforms/WFSFormAdress.form
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/wfsforms/WFSFormAdress.form,v
retrieving revision 1.10
diff -c -r1.10 WFSFormAdress.form
*** de/cismet/cismap/commons/wfsforms/WFSFormAdress.form	12 Feb 2008 10:43:31 -0000	1.10
--- de/cismet/cismap/commons/wfsforms/WFSFormAdress.form	19 Mar 2009 14:56:42 -0000
***************
*** 49,54 ****
--- 49,57 ----
        <Events>
          <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="cmdOkActionPerformed"/>
        </Events>
+       <AuxValues>
+         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+       </AuxValues>
        <Constraints>
          <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout" value="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout$GridBagConstraintsDescription">
            <GridBagConstraints gridX="2" gridY="0" gridWidth="1" gridHeight="1" fill="0" ipadX="0" ipadY="0" insetsTop="0" insetsLeft="2" insetsBottom="0" insetsRight="0" anchor="18" weightX="0.0" weightY="0.0"/>
***************
*** 188,200 ****
              <EmptyBorder bottom="0" left="0" right="0" top="0"/>
            </Border>
          </Property>
-         <Property name="margin" type="java.awt.Insets" editor="org.netbeans.beaninfo.editors.InsetsEditor">
-           <Insets value="[0, 0, 0, 0]"/>
-         </Property>
        </Properties>
        <Events>
          <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="chkVisualizeActionPerformed"/>
        </Events>
        <Constraints>
          <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout" value="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout$GridBagConstraintsDescription">
            <GridBagConstraints gridX="3" gridY="0" gridWidth="1" gridHeight="1" fill="0" ipadX="0" ipadY="0" insetsTop="5" insetsLeft="7" insetsBottom="0" insetsRight="0" anchor="18" weightX="0.0" weightY="0.0"/>
--- 191,203 ----
              <EmptyBorder bottom="0" left="0" right="0" top="0"/>
            </Border>
          </Property>
        </Properties>
        <Events>
          <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="chkVisualizeActionPerformed"/>
        </Events>
+       <AuxValues>
+         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+       </AuxValues>
        <Constraints>
          <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout" value="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout$GridBagConstraintsDescription">
            <GridBagConstraints gridX="3" gridY="0" gridWidth="1" gridHeight="1" fill="0" ipadX="0" ipadY="0" insetsTop="5" insetsLeft="7" insetsBottom="0" insetsRight="0" anchor="18" weightX="0.0" weightY="0.0"/>
***************
*** 208,213 ****
--- 211,219 ----
          </Property>
          <Property name="toolTipText" type="java.lang.String" value="Markierung anzeigen"/>
        </Properties>
+       <AuxValues>
+         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+       </AuxValues>
        <Constraints>
          <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout" value="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout$GridBagConstraintsDescription">
            <GridBagConstraints gridX="4" gridY="0" gridWidth="1" gridHeight="1" fill="0" ipadX="0" ipadY="0" insetsTop="4" insetsLeft="7" insetsBottom="0" insetsRight="0" anchor="18" weightX="0.0" weightY="0.0"/>
***************
*** 223,232 ****
              <EmptyBorder bottom="0" left="0" right="0" top="0"/>
            </Border>
          </Property>
-         <Property name="margin" type="java.awt.Insets" editor="org.netbeans.beaninfo.editors.InsetsEditor">
-           <Insets value="[0, 0, 0, 0]"/>
-         </Property>
        </Properties>
        <Constraints>
          <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout" value="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout$GridBagConstraintsDescription">
            <GridBagConstraints gridX="5" gridY="0" gridWidth="1" gridHeight="1" fill="0" ipadX="0" ipadY="0" insetsTop="5" insetsLeft="14" insetsBottom="0" insetsRight="0" anchor="18" weightX="0.0" weightY="0.0"/>
--- 229,238 ----
              <EmptyBorder bottom="0" left="0" right="0" top="0"/>
            </Border>
          </Property>
        </Properties>
+       <AuxValues>
+         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+       </AuxValues>
        <Constraints>
          <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout" value="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout$GridBagConstraintsDescription">
            <GridBagConstraints gridX="5" gridY="0" gridWidth="1" gridHeight="1" fill="0" ipadX="0" ipadY="0" insetsTop="5" insetsLeft="14" insetsBottom="0" insetsRight="0" anchor="18" weightX="0.0" weightY="0.0"/>
***************
*** 238,245 ****
          <Property name="icon" type="javax.swing.Icon" editor="org.netbeans.modules.form.editors2.IconEditor">
            <Image iconType="3" name="/de/cismet/cismap/commons/gui/res/fixMapScale.png"/>
          </Property>
!         <Property name="toolTipText" type="java.lang.String" value="Ma&#xdf;stab beibehalten"/>
        </Properties>
        <Constraints>
          <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout" value="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout$GridBagConstraintsDescription">
            <GridBagConstraints gridX="6" gridY="0" gridWidth="1" gridHeight="1" fill="0" ipadX="0" ipadY="0" insetsTop="2" insetsLeft="7" insetsBottom="4" insetsRight="0" anchor="18" weightX="0.0" weightY="0.0"/>
--- 244,254 ----
          <Property name="icon" type="javax.swing.Icon" editor="org.netbeans.modules.form.editors2.IconEditor">
            <Image iconType="3" name="/de/cismet/cismap/commons/gui/res/fixMapScale.png"/>
          </Property>
!         <Property name="toolTipText" type="java.lang.String" value="Ma&#xdf;stab beibehalten" noResource="true"/>
        </Properties>
+       <AuxValues>
+         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+       </AuxValues>
        <Constraints>
          <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout" value="org.netbeans.modules.form.compat2.layouts.DesignGridBagLayout$GridBagConstraintsDescription">
            <GridBagConstraints gridX="6" gridY="0" gridWidth="1" gridHeight="1" fill="0" ipadX="0" ipadY="0" insetsTop="2" insetsLeft="7" insetsBottom="4" insetsRight="0" anchor="18" weightX="0.0" weightY="0.0"/>
***************
*** 264,270 ****
        <Layout>
          <DimensionLayout dim="0">
            <Group type="103" groupAlignment="0" attributes="0">
!               <EmptySpace min="0" pref="97" max="32767" attributes="0"/>
            </Group>
          </DimensionLayout>
          <DimensionLayout dim="1">
--- 273,279 ----
        <Layout>
          <DimensionLayout dim="0">
            <Group type="103" groupAlignment="0" attributes="0">
!               <EmptySpace min="0" pref="86" max="32767" attributes="0"/>
            </Group>
          </DimensionLayout>
          <DimensionLayout dim="1">
Index: de/cismet/cismap/commons/wfsforms/WFSFormAdress.java
===================================================================
RCS file: /cvs/cismapCommons/src/de/cismet/cismap/commons/wfsforms/WFSFormAdress.java,v
retrieving revision 1.19
diff -c -r1.19 WFSFormAdress.java
*** de/cismet/cismap/commons/wfsforms/WFSFormAdress.java	7 Mar 2008 11:23:31 -0000	1.19
--- de/cismet/cismap/commons/wfsforms/WFSFormAdress.java	19 Mar 2009 14:56:42 -0000
***************
*** 199,205 ****
          chkVisualize.setSelected(true);
          chkVisualize.setToolTipText("Markierung anzeigen");
          chkVisualize.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
-         chkVisualize.setMargin(new java.awt.Insets(0, 0, 0, 0));
          chkVisualize.addActionListener(new java.awt.event.ActionListener() {
              public void actionPerformed(java.awt.event.ActionEvent evt) {
                  chkVisualizeActionPerformed(evt);
--- 199,204 ----
***************
*** 222,230 ****
          add(jLabel1, gridBagConstraints);
  
          chkLockScale.setSelected(true);
!         chkLockScale.setToolTipText("Ma\u00DFstab beibehalten");
          chkLockScale.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
-         chkLockScale.setMargin(new java.awt.Insets(0, 0, 0, 0));
          gridBagConstraints = new java.awt.GridBagConstraints();
          gridBagConstraints.gridx = 5;
          gridBagConstraints.gridy = 0;
--- 221,228 ----
          add(jLabel1, gridBagConstraints);
  
          chkLockScale.setSelected(true);
!         chkLockScale.setToolTipText("Maßstab beibehalten");
          chkLockScale.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
          gridBagConstraints = new java.awt.GridBagConstraints();
          gridBagConstraints.gridx = 5;
          gridBagConstraints.gridy = 0;
***************
*** 233,239 ****
          add(chkLockScale, gridBagConstraints);
  
          jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cismap/commons/gui/res/fixMapScale.png"))); // NOI18N
!         jLabel2.setToolTipText("Ma\u00DFstab beibehalten");
          gridBagConstraints = new java.awt.GridBagConstraints();
          gridBagConstraints.gridx = 6;
          gridBagConstraints.gridy = 0;
--- 231,237 ----
          add(chkLockScale, gridBagConstraints);
  
          jLabel2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/de/cismet/cismap/commons/gui/res/fixMapScale.png"))); // NOI18N
!         jLabel2.setToolTipText("Maßstab beibehalten"); // NOI18N
          gridBagConstraints = new java.awt.GridBagConstraints();
          gridBagConstraints.gridx = 6;
          gridBagConstraints.gridy = 0;
***************
*** 248,254 ****
          panEmpty.setLayout(panEmptyLayout);
          panEmptyLayout.setHorizontalGroup(
              panEmptyLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
!             .add(0, 97, Short.MAX_VALUE)
          );
          panEmptyLayout.setVerticalGroup(
              panEmptyLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
--- 246,252 ----
          panEmpty.setLayout(panEmptyLayout);
          panEmptyLayout.setHorizontalGroup(
              panEmptyLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
!             .add(0, 86, Short.MAX_VALUE)
          );
          panEmptyLayout.setVerticalGroup(
              panEmptyLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
***************
*** 340,350 ****
      // Variables declaration - do not modify//GEN-BEGIN:variables
      private javax.swing.JComboBox cboNr;
      private javax.swing.JComboBox cboStreets;
!     private javax.swing.JCheckBox chkLockScale;
!     private javax.swing.JCheckBox chkVisualize;
!     private javax.swing.JButton cmdOk;
!     private javax.swing.JLabel jLabel1;
!     private javax.swing.JLabel jLabel2;
      private javax.swing.JPanel jPanel3;
      private javax.swing.JPanel panEmpty;
      private javax.swing.JPanel panNr;
--- 338,348 ----
      // Variables declaration - do not modify//GEN-BEGIN:variables
      private javax.swing.JComboBox cboNr;
      private javax.swing.JComboBox cboStreets;
!     protected javax.swing.JCheckBox chkLockScale;
!     protected javax.swing.JCheckBox chkVisualize;
!     protected javax.swing.JButton cmdOk;
!     protected javax.swing.JLabel jLabel1;
!     protected javax.swing.JLabel jLabel2;
      private javax.swing.JPanel jPanel3;
      private javax.swing.JPanel panEmpty;
      private javax.swing.JPanel panNr;
